module Filtration (Filtration) where

import Prelude hiding (Left, Right)
import DA.Next.Map
import DA.Bifunctor
import IOr

-- A left value is true for every t, a right value only for given t's that are in the map's keys.
newtype Filtration d a = Filtration (IOr a (Map d a))

instance (MapKey d) => Functor (Filtration d) where
  fmap f (Filtration ior) = Filtration $ bimap f (fmap f) ior

-- n.b. Returns an intersection of the dates
instance (MapKey d) => Applicative (Filtration d) where --TODO: use GenMap, remove key constraint
  pure a = Filtration . Left $ a
  Filtration (Left f) <*> Filtration as = Filtration $ bimap f (fmap f) as
  Filtration (Right fs) <*> Filtration (Left a) = Filtration . Right $ fmap ($ a) fs
  Filtration (Right fs) <*> Filtration (Right as) =
    Filtration . Right $ merge (\_ _ -> None) (\_ _ -> None) (\_ f a -> Some $ f a) fs as
  Filtration (Right fs) <*> Filtration (Both a as) =
    Filtration . Right $ merge (\_ f -> Some $ f a) (\_ _ -> None) (\_ f a -> Some $ f a) fs as
  Filtration (Both f gs) <*> Filtration (Left a) = Filtration Both with
    left = f a
    right = fmap ($ a) gs
  Filtration (Both f gs) <*> Filtration (Right as) = 
    Filtration . Right $ merge (\_ _ -> None) (\_ a -> Some $ f a) (\_ g a -> Some $ g a) gs as
  Filtration (Both f gs) <*> Filtration (Both a as) = 
    Filtration Both with
      left = f a
      right = 
        merge (\_ g -> Some $ g a) (\_ a -> Some $ f a) (\_ g a -> Some $ g a) gs as
