module Filtration (Filtration) where

import Prelude hiding (Left, Right, lookup)
import DA.Next.Map
import DA.Bifunctor
import IOr
import DA.Optional (fromOptional)

-- A left value is true for every t, a right value only for given t's that are in the map's keys.
newtype Filtration t a = Filtration (IOr a (Map t a))

instance (MapKey t) => Functor (Filtration t) where
  fmap f (Filtration ior) = Filtration $ bimap f (fmap f) ior

-- n.b. Returns an intersection of the dates
instance (MapKey t) => Applicative (Filtration t) where --TODO: use GenMap, remove key constraint
  pure a = Filtration . Left $ a
  Filtration (Left f) <*> Filtration as = Filtration $ bimap f (fmap f) as
  Filtration (Right fs) <*> Filtration (Left a) = Filtration . Right $ fmap ($ a) fs
  Filtration (Right fs) <*> Filtration (Right as) =
    Filtration . Right $ merge (\_ _ -> None) (\_ _ -> None) (\_ f a -> Some $ f a) fs as
  Filtration (Right fs) <*> Filtration (Both a as) =
    Filtration . Right $ merge (\_ f -> Some $ f a) (\_ _ -> None) (\_ f a -> Some $ f a) fs as
  Filtration (Both f gs) <*> Filtration (Left a) = Filtration Both with
    left = f a
    right = fmap ($ a) gs
  Filtration (Both f gs) <*> Filtration (Right as) = 
    Filtration . Right $ merge (\_ _ -> None) (\_ a -> Some $ f a) (\_ g a -> Some $ g a) gs as
  Filtration (Both f gs) <*> Filtration (Both a as) = 
    Filtration Both with
      left = f a
      right = 
        merge (\_ g -> Some $ g a) (\_ a -> Some $ f a) (\_ g a -> Some $ g a) gs as

run : (MapKey t) => Filtration t a -> t -> Optional a
run (Filtration (Left a)) _ = Some a
run (Filtration (Right as)) t = lookup t as
run (Filtration (Both a as)) t = Some $ fromOptional a (lookup t as)
