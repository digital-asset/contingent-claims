module Observation where

import Const
import Observable qualified as O

import DA.Record (HasField)
import Kleisli
-- import DA.Generics

eval : (Template t, HasField "lhs" t a) => ContractId t -> Update a
eval = fmap (.lhs) . fetch

data ObservationWrapper a
  = BooleanObservation_ (ContractId BooleanObservation) --TODO: consider removing ContractId. That would allow pure values.
  | DecimalObservation_ (ContractId DecimalObservation)
  | DateObservation_ (ContractId DateObservation)

template BooleanObservation
  with
    provider: Party
    lhs: Bool
  where
    signatory provider
    controller provider can
      And: ContractId BooleanObservation with rhs: ContractId BooleanObservation do
        rhs <- eval rhs
        create BooleanObservation with provider, lhs = lhs && rhs

template DecimalObservation
  with
    provider: Party
    lhs: Decimal
  where 
    signatory provider
    controller provider can
      DecimalAdd : ContractId DecimalObservation with rhs: ContractId DecimalObservation do
        rhs <- eval rhs
        create DecimalObservation with provider, lhs = lhs + rhs
      DecimalLte : ContractId BooleanObservation with rhs: ContractId DecimalObservation do
        rhs <- eval rhs
        create BooleanObservation with provider, lhs = lhs <= rhs

template DateObservation
  with 
    provider: Party
    lhs: Date
  where
    signatory provider
    controller provider can
      DateLte : ContractId BooleanObservation with rhs: ContractId DateObservation do
        rhs <- eval rhs
        create BooleanObservation with provider, lhs = lhs < rhs
    
newtype UpdateT m a = UpdateT { run : Update (m a) }

instance O.TimeF (Kleisli (UpdateT ObservationWrapper)) (Party, Date) where
  time = Kleisli \(provider, t) -> UpdateT do
    cid <- create DateObservation with provider, lhs = t
    return $ DateObservation_ cid

instance O.PointF (Kleisli (UpdateT ObservationWrapper)) (Party, t) Decimal where
  pure d = Kleisli \(provider, _t) ->  UpdateT do
    cid <- create DecimalObservation with provider, lhs = d
    return $ DecimalObservation_ cid

instance O.PointF (Kleisli (UpdateT ObservationWrapper)) (Party, t) Date where
  pure d = Kleisli \(provider, _t) ->  UpdateT do
    cid <- create DateObservation with provider, lhs = d
    return $ DateObservation_ cid

instance O.InequalityF (Kleisli (UpdateT ObservationWrapper)) (Party, t) Decimal where
  lhs <= rhs = Kleisli \x -> UpdateT do
    rhs <- (rhs.runKleisli x).run
    lhs <- (lhs.runKleisli x).run
    case (lhs, rhs) of
      (DecimalObservation_ lhsCid, DecimalObservation_ rhsCid) -> do
         resCid <- exercise lhsCid DecimalLte with rhs = rhsCid
         pure $ BooleanObservation_ resCid
      (DateObservation_ lhsCid, DateObservation_ rhsCid) -> do
         resCid <- exercise lhsCid DateLte with rhs = rhsCid
         pure $ BooleanObservation_ resCid
      _ -> error "Inequality between different types" -- this should be impossible, provided you use the smart constructors
  (==) = undefined
