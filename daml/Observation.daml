module Observation where

import Const
import Observable
import Observable qualified as O (pure,(<=), (==),(+))
import Prelude
import Prelude qualified (pure, (<=),(==))
import DA.Date (Month(..), date)

data Observation t a
  = Identity
  | Konst a
  | Sum with lhs: Observation t a, rhs: Observation t a
  | Lte with lhs: Observation t a, rhs: Observation t a
  | Equ with lhs: Observation t a, rhs: Observation t a
  deriving (Eq, Show)

{- We use a trick to control the output type of the effect.
   The type @ObsArrow a@ is our f, so we have type @Obligation (ObsArrow a) t b@.
   We can 'rig' the result type @b@ by mapping over @Const@ (see below).
-}
newtype ObsArrow a t b = ObsArrow (Const (Observation t a) b) deriving (Eq, Show)

instance forall t a . TimeF (ObsArrow a) t where
  time = ObsArrow . Const $ Identity

instance forall t a . PointF (ObsArrow a) t a where
  pure = ObsArrow . Const . Konst

instance forall t a b . Additive a => NumberF (ObsArrow a t) b where
  zero = ObsArrow . Const $ Konst aunit
  ObsArrow (Const fa) + ObsArrow (Const fa') = ObsArrow . Const $ Sum fa fa'

instance forall t a b . Ord a => InequalityF (ObsArrow a t) b where
  ObsArrow (Const fb) <= ObsArrow (Const fb') = ObsArrow $ fmap (const True) (Const (Lte fb fb'))
  ObsArrow (Const fb) == ObsArrow (Const fb') = ObsArrow $ fmap (const True) (Const (Equ fb fb'))

-- x : ObsArrow Date Date Bool = time O.<= O.pure (date 2020 Nov 23)
-- y : ObsArrow Int Date Int = O.pure 1 O.+ O.pure 2

{-
This works:

x : ObsArrow Date Date Bool = time O.<= O.pure (date 2020 Nov 23)

But this doesn't:

x : ObsArrow Date Date Bool = (time O.<= O.pure (date 2020 Nov 23) O.== True)

i.e. you can only nest an inequality _once_ inside an addition. This is the
tradeoff we have for being able lift _any_ type into our representation, rather
than using a fixed algebra (i.e. BoolLte, IntLte etc.). 

It may be possible to somehow capture the depth of the expressions in an HList in
the @a@ position, to allow an arbitrary depth.

-}
