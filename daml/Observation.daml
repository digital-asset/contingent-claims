module Observation where

import DA.Next.Map
import Prelude
import Prelude qualified ((<=),(==),(+))

newtype Kleisli a b = Kleisli { run : a -> Update b }

instance forall t . Functor (Kleisli t) where
  fmap = undefined

instance forall t . Applicative (Kleisli t) where
  pure = undefined
  (<*>) = undefined

class Observation f t a | t a -> f t a where
  (+) : f t a -> f t a -> f t a
  (===): f t a -> f t a -> f t Bool

template ObservationDecimalInequalityAlgebra
  with 
    p: Party
  where
    signatory p
    key p : Party
    maintainer key
    controller p can
      nonconsuming Equals : Bool with lhsDecimal: Decimal, rhsDecimal: Decimal do pure $ lhsDecimal == rhsDecimal
  
instance (Eq a, Number a) => Observation Kleisli t a where
  fa + fa' = liftA2 (Prelude.+) fa fa'
  (===) = liftA2 (Prelude.==)

-- A serializable Observation
newtype Obs = Obs { run : Either 


{-
data Observation t a
  = Identity
  | Const a
  | Observation (Map t a)
  | LiftA2 with op: Op, lhs: Observation t a, rhs: Observation t a
  deriving Eq

data Op
  = Sum
  | Lte
  | Eq'
  deriving (Eq)

instance Additive a => Additive (Observation t a) where
  aunit = Const aunit
  (+) = LiftA2 Sum

class ObservationOrd a where
  (<=) : a -> a -> a
  (==) : a -> a -> a

instance Ord a => ObservationOrd (Observation t a) where
  (<=) = LiftA2 Lte
  (==) = LiftA2 Eq'
-}
