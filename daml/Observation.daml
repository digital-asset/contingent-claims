module Observation where

import Prelude
import Prelude qualified ((<=),(==),(+))
import Const

{-

newtype Kleisli a b = Kleisli { run : a -> Update b }

instance forall t . Functor (Kleisli t) where
  fmap = undefined

instance forall t . Applicative (Kleisli t) where
  pure = undefined
  (<*>) = undefined

class Observation f t a where -- | t a -> f t a where
  (+) : f t a -> f t a -> f t a
  (===): f t a -> f t a -> f t Bool

template ObservationDecimalInequalityAlgebra
  with 
    p: Party
  where
    signatory p
    key p : Party
    maintainer key
    controller p can
      nonconsuming DecimalEquals : Bool with lhsDecimal: Decimal, rhsDecimal: Decimal do pure $ lhsDecimal == rhsDecimal
  
{-instance (Eq a, Number a) => Observation Kleisli t a where
  fa + fa' = liftA2 (Prelude.+) fa fa'
  (===) = liftA2 (Prelude.==)
-}

instance HasExercise templ DecimalEquals r => Observation (Obs templ ceq) t r where
  -- Obs{run = Left a} + Obs{run = Left a'} = Obs (Left a)
  Obs{run = r} === Obs{run = r'} = Obs (DecimalEquals r r')

-- A serializable Observation
newtype Obs templ ceq t a = Obs { run : ceq }
-}

data Observation t a
  = Identity
  | Konst a
  | Sum with lhs: Observation t a, rhs: Observation t a
  | Lte with lhs: Observation t a, rhs: Observation t a
  | Equ with lhs: Observation t a, rhs: Observation t a
  deriving Eq

instance Additive a => Additive (Const (Observation t a) a) where
  aunit = Const $ Konst aunit
  Const fa + Const fa' = Const $ Sum fa fa'

class InequalityF f a where
  (<=) : f a -> f a -> f Bool
  (==) : f a -> f a -> f Bool

instance InequalityF (Const (Observation t a)) b where
  Const fb <= Const fb' = fmap (const True) (Const (Lte fb fb'))
  Const fb == Const fb' = fmap (const True) (Const (Equ fb fb'))
