module Observation where

import DA.Next.Map
import Prelude
import Prelude qualified ((<=),(==),(+))

{-

newtype Kleisli a b = Kleisli { run : a -> Update b }

instance forall t . Functor (Kleisli t) where
  fmap = undefined

instance forall t . Applicative (Kleisli t) where
  pure = undefined
  (<*>) = undefined

class Observation f t a where -- | t a -> f t a where
  (+) : f t a -> f t a -> f t a
  (===): f t a -> f t a -> f t Bool

template ObservationDecimalInequalityAlgebra
  with 
    p: Party
  where
    signatory p
    key p : Party
    maintainer key
    controller p can
      nonconsuming DecimalEquals : Bool with lhsDecimal: Decimal, rhsDecimal: Decimal do pure $ lhsDecimal == rhsDecimal
  
{-instance (Eq a, Number a) => Observation Kleisli t a where
  fa + fa' = liftA2 (Prelude.+) fa fa'
  (===) = liftA2 (Prelude.==)
-}

instance HasExercise templ DecimalEquals r => Observation (Obs templ ceq) t r where
  -- Obs{run = Left a} + Obs{run = Left a'} = Obs (Left a)
  Obs{run = r} === Obs{run = r'} = Obs (DecimalEquals r r')

-- A serializable Observation
newtype Obs templ ceq t a = Obs { run : ceq }
-}

data Observation t a
  = Identity
  | Const a
  | Observation (Map t a)
  | LiftA2 with op: Op, lhs: Observation t a, rhs: Observation t a
  deriving Eq

data Op
  = Sum
  | Lte
  | Eq'
  deriving (Eq)

instance Additive a => Additive (Observation t a) where
  aunit = Const aunit
  (+) = LiftA2 Sum

class ObservationOrd a where
  (<=) : a -> a -> a
  (==) : a -> a -> a

instance Ord a => ObservationOrd (Observation t a) where
  (<=) = LiftA2 Lte
  (==) = LiftA2 Eq'
