module Observation where

import Observable qualified as O

import DA.Record (HasField)
import Kleisli
-- import DA.Generics

-- Party -> t -> Update Observation a
newtype Observation t a = Observation { run : Kleisli (Kleisli (UpdateT ObservationWrapper) t) Party a }

eval : (Template t, HasField "lhs" t a) => ContractId t -> Update a
eval = fmap (.lhs) . fetch

data ObservationWrapper a
  = BooleanObservation_ (ContractId BooleanObservation) --TODO: consider removing ContractId. That would allow pure values.
  | DecimalObservation_ (ContractId DecimalObservation)
  | DateObservation_ (ContractId DateObservation)

template BooleanObservation
  with
    provider: Party
    lhs: Bool
  where
    signatory provider
    controller provider can
      And: ContractId BooleanObservation with rhs: ContractId BooleanObservation do
        rhs <- eval rhs
        create BooleanObservation with provider, lhs = lhs && rhs

template DecimalObservation
  with
    provider: Party
    lhs: Decimal
  where 
    signatory provider
    controller provider can
      DecimalAdd : ContractId DecimalObservation with rhs: ContractId DecimalObservation do
        rhs <- eval rhs
        create DecimalObservation with provider, lhs = lhs + rhs
      DecimalLte : ContractId BooleanObservation with rhs: ContractId DecimalObservation do
        rhs <- eval rhs
        create BooleanObservation with provider, lhs = lhs <= rhs

template DateObservation
  with 
    provider: Party
    lhs: Date
  where
    signatory provider
    controller provider can
      DateLte : ContractId BooleanObservation with rhs: ContractId DateObservation do
        rhs <- eval rhs
        create BooleanObservation with provider, lhs = lhs < rhs
    
newtype UpdateT m a = UpdateT { run : Update (m a) }

instance O.TimeF Observation Date where
  time = Observation $
    Kleisli \provider -> 
      Kleisli \t -> UpdateT do
        cid <- create DateObservation with provider, lhs = t
        return $ DateObservation_ cid

instance O.PointF Observation t Decimal where
  pure d = Observation $
    Kleisli \provider ->
      Kleisli \_t ->  UpdateT do
        cid <- create DecimalObservation with provider, lhs = d
        return $ DecimalObservation_ cid

instance O.PointF Observation t Date where
  pure d = Observation $
    Kleisli \provider ->
      Kleisli \_t ->  UpdateT do
        cid <- create DateObservation with provider, lhs = d
        return $ DateObservation_ cid

instance O.InequalityF Observation t Decimal where
  lhs <= rhs = Observation $ 
    Kleisli \provider -> 
      Kleisli \t -> UpdateT do
        rhs <- ((rhs.run.runKleisli provider).runKleisli t).run
        lhs <- ((lhs.run.runKleisli provider).runKleisli t).run
        case (lhs, rhs) of
          (DecimalObservation_ lhsCid, DecimalObservation_ rhsCid) -> do
             resCid <- exercise lhsCid DecimalLte with rhs = rhsCid
             pure $ BooleanObservation_ resCid
          _ -> error "Inequality between different types" 
          -- ^ this should be impossible, provided you use the smart constructors
  (==) = undefined

instance O.InequalityF Observation t Date where
  lhs <= rhs = Observation $ 
    Kleisli \provider -> 
      Kleisli \t -> UpdateT do
        rhs <- ((rhs.run.runKleisli provider).runKleisli t).run
        lhs <- ((lhs.run.runKleisli provider).runKleisli t).run
        case (lhs, rhs) of
          (DateObservation_ lhsCid, DateObservation_ rhsCid) -> do
             resCid <- exercise lhsCid DateLte with rhs = rhsCid
             pure $ BooleanObservation_ resCid
          _ -> error "Inequality between different types" 
          -- ^ this should be impossible, provided you use the smart constructors
  (==) = undefined
