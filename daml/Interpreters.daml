-- {-# LANGUAGE TypeOperators #-}
module Interpreters where

import Obligation (Obligation, Obligation(..), ObligationF(..))
import Observation (Observation, eval)
import Kleisli
import Recursion
-- import DA.Action ((<=<))
import Profunctor

type Obligations a = Obligation Observation Date a
type ObligationsF a = ObligationF Observation Date a

-- Returns a function that executes 'runClear' on nodes that are 'current' at time t.
-- Uses 'runSpot' to lookup spot prices.
clear :  (a -> Decimal -> Date -> Update c) 
      -> (Text -> Date -> Update Decimal) 
      -> Obligations a 
      -> Date -> Update [c]
clear runClear runSpot o = runKleisli (runKleisli (cata reify o) 1.0)
  where 
    -- reify : ObligationF Observation t a (Kleisli (Kleisli Update t) Decimal [c]) -> (Kleisli (Kleisli Update t) Decimal [c])
    -- ^ Uses an continuation to 'bubble up' the scale factor.
    -- | TODO: re-write to evalute observations eagerly, and prune stale nodes top-down. Currently this traverses the entire tree (even stale nodes).
    -- | FIXME: For some reason the signatures aren't compiling.
    reify = \case
      ZeroF -> skip
      OneF a -> do 
        c <- runClear' a
        return [c]
      GiveF _ -> skip
      AndF g g' -> liftA2 (++) g g'
      OrF _ _ -> error "clear: 'Or' unimplemented" -- TODO: another param, allowing you to pass the 'g' to match
      CondF p g g' -> conditionally p g g'
      ScaleF k g -> do
        k <- lift . eval runSpot $ k
        lmap (k *) g
      WhenF p g -> conditionally p g skip
      AnytimeF p g -> conditionally p g skip
      UntilF p g -> conditionally p g skip --FIXME: this is incorrect

    conditionally p g g' = do
      p <- lift . eval runSpot $ p
      if p then g else g'
   
    skip = pure []
                
    -- runClear' : a -> (Kleisli (Kleisli Update t) Decimal c)
    runClear' a =  Kleisli (rmap Kleisli (runClear a))

lift : Kleisli Update t m -> Kleisli (Kleisli Update t) Decimal m
lift = Kleisli . const 

data StateT m s a = StateT (m (s, a))

instance Functor (StateT m s) where
  fmap = undefined

instance Applicative (StateT m s) where
  pure = undefined
  (<*>) = undefined

instance Action (StateT m s) where
  (>>=) = undefined

{-
reify : (x -> ObligationF Observation t a (StateT Update Decimal x)) -> x -> StateT Update Decimal x
reify = undefined

x tradeDate = reify \case
            Scale k o -> ScaleF k $ StateT $ fmap (,o) (runKleisli . eval lookup k $ tradeDate)
            When p o -> WhenF p $ StateT $ fmap (\p -> (1.0, if p then o else Zero)) (runKleisli . eval lookup p $ tradeDate)
          (undefined: Obligation Observation Date Text)
-}

-- Prune the node with given asset/quantity/date
-- FIXME: this should only prune a _single_ instance of that node.
prune
  : Eq a 
  => (Text -> Date -> Update Decimal) 
  -> a -> Decimal
  -> Obligations a 
  -> Date -> Update (Obligations a)
prune runSpot asset qty o = runKleisli (runKleisli (para prune' o) 1.0)
  where {- prune' : ObligationsF a (Obligations a, Kleisli (Kleisli Update Date) Decimal (Obligations a)) 
              -> Kleisli (Kleisli Update Date) Decimal (Obligations a) -}
        prune' ZeroF = pure Zero
        prune' (OneF a') = 
          Kleisli \qty' ->
            Kleisli \_ ->
              if qty' == qty && asset == a' then pure Zero else pure $ One a'
        prune' (ScaleF k (_, g)) = do
          k <- lift . eval runSpot $ k
          lmap (k *) g
        prune' (WhenF p (o, g)) = do
          b <- lift . eval runSpot $ p
          if b then g else pure $ When p o
        prune' (AndF (o, g) (o', g')) = do -- TODO: this can be optimized to eval rhs lazily
          trimmed <- g
          trimmed' <- g'
          case (trimmed, trimmed') of 
            (Zero, _) -> pure trimmed'
            (_, Zero) -> pure trimmed
            _ -> pure $ And o o' 
        prune' _ = error "prune' : unimplemented"

