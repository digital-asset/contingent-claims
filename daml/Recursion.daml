module Recursion where

import Category ((>>>),(<<<))
import Arrow ((&&&),(|||))

newtype Fix f = Fix { unfix : f (Fix f) }
data Free f a 
  = Pure a
  | Impure (f (Free f a))

data Cofree f a = Cofree {
  attribute : a,
  hole : f (Cofree f a)
}

class Functor f => Recursive b f | b -> f b where
  project: b -> f b

  cata : (f a -> a) -> b -> a
  cata f x = (project >>> fmap (cata f) >>> f) x

  para : (f (b, a) -> a) -> b -> a
  para f x = (project >>> fmap (identity &&& para f) >>> f) x

  histo : (f (Cofree f a) -> a) -> b -> a
  histo f x = (_histo f >>> (.attribute)) x

-- Helper for histo, can't be inlined as it's self-referencing.
_histo : Recursive b f => (f (Cofree f a) -> a) -> b -> Cofree f a
_histo f b = (project >>> fmap (_histo f) >>> (f &&& identity) >>> uncurry Cofree) b

class Functor f => Corecursive b f | f -> b where
  embed: f b -> b

  ana : (a -> f a) -> a -> b
  ana f x = (embed <<< fmap (ana f) <<< f) x

  apo : (a -> f (Either b a)) -> a -> b
  apo f x = (embed <<< fmap (identity ||| apo f) <<< f) x

-- Standard Base Functors

data ListF a x = Nil | Cons with value: a, pattern: x deriving Functor

instance Recursive [a] (ListF a) where
  project [] = Nil
  project (a :: as) = Cons a as

instance Corecursive [a] (ListF a) where
  embed Nil = []
  embed (Cons a as) = a :: as

oursum = cata \case
           Nil -> 0
           Cons x acc -> acc + x

s = oursum [1..20]
