module Recursion where

import Category ((>>>),(<<<))

newtype Fix f = Fix { unfix : f (Fix f) }

class Functor f => Recursive t f | t -> f t where
  project: t -> f t

  cata : (f a -> a) -> t -> a
  cata f = project >>> fmap (cata f) >>> f

  para : (f (t, a) -> a) -> t -> a
  para f = project >>> fmap ((,) <*> para f) >>> f

class Functor f => Corecursive t f where
  embed: f t -> t

  ana : (a -> f a) -> a -> t
  ana f = embed <<< fmap (ana f) <<< f

-- Standard Base Functors

data ListF a x = Nil | Cons with value: a, pattern: x deriving Functor

instance Recursive [a] (ListF a) where
  project [] = Nil
  project (a :: as) = Cons a as

instance Corecursive [a] (ListF a) where
  embed Nil = []
  embed (Cons a as) = a :: as

oursum = cata \case
           Nil -> 0
           Cons x acc -> acc + x

s = oursum [1..20]
