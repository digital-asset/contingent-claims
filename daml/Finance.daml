daml 1.2
module Finance where

newtype Fix f = Fix { unfix : f (Fix f) }

undefined = error "Undefined"

-- This is basically a reader monad
newtype Obs a = Obs (Date -> (PR a)) -- TODO: should we parametrize Date too?
  deriving Functor

-- Stochastic process / filtration
newtype PR a = PR [RV a] 
  deriving Show

-- Random variable PMF - could use a PDF too?
type RV a = [a]

instance Show (Obs a) where
  show _ = "Obs(t -> ?)"

instance Functor PR where
  fmap f (PR rvs) = PR $ 
    fmap (\rv -> fmap f rv) rvs

instance Applicative PR where
  pure a = PR [[a]]
  (<*>) (PR fs) (PR as) = PR $ do
    f' <- fs
    f <- f'
    a' <- as
    return $ fmap f a'

instance Applicative Obs where -- how to derive this automagically?
  pure a = Obs (pure (pure a))
  (<*>) (Obs fs) (Obs gs) = Obs $
     \d -> fs d <*> gs d
    
-- Can either be an external source, or pricing for bespoke contracts for a counterparty
{-
template MarketData with
    provider: Party
    subscribers: Set Party
  where 
    signatory provider
    controller subscribers can 
      -- Retrieve a quote
      nonconsuming quote: PR[Decimal] with date: Date, asset: Currency, q: Text where undefined
      -- Retrieve a binary state e.g. is trading day?
      nonconsuming state: PR[Bool] with date: Date, asset: Currency, q: Text where undefined
-}

template Contract with
    buyer: Party
    seller: Party
  where
    signatory buyer, seller

-- In Petyon-Jones' paper, this is called 'Contract'.
-- We renamed it to allow our top-level (template) to be Contract.
data Obligation a = Zero
  | One Currency -- Does this need to be parametrized? Otherwise this only works for cash-settled securities.
  | Give (Obligation a)
  | And with lhs: (Obligation a), rhs: (Obligation a)
  | Or with lhs: (Obligation a), rhs: (Obligation a)
  | Cond with predicate: (Obs Bool), t: (Obligation a), f: (Obligation a)
  | Scale with k: (Obs Decimal), x: (Obligation a) -- TODO: Decimal -> Numeric ? 
  | When with o: (Obs Bool), x: (Obligation a)
  | Anytime with o: (Obs Bool), x: (Obligation a)
  | Until with o: (Obs Bool), x: (Obligation a)
  deriving (Show)

one = One

and c1 c2 = And c1 c2

or c1 c2 = Or c1 c2

cond p c1 c2 = Cond p c1 c2

scale k c1 = Scale k c1

when o c1 = When o c1

anytime o c1 = Anytime o c1

until o c1 = Until o c1

data Currency = GBP
  deriving (Show, Eq)

zcb : Date -> Decimal -> Currency -> Obligation (Fix Obligation)
zcb maturity payoff ccy = 
  when (at maturity) $ scale (pure payoff) (one ccy)

at : Date -> Obs Bool
at t = liftA2 (==) date (pure t)

date : Obs Date
date = Obs $ pure

european : Date -> Obligation (Fix Obligation) -> Obligation (Fix Obligation)
european t u = when (at t) (u `Finance.or` Zero)

american : (Date, Date) -> Obligation (Fix Obligation) -> Obligation (Fix Obligation)
american (t1, t2) u = anytime (between t1 t2) u

between : Date -> Date -> Obs Bool
between t1 t2 = liftA2 (&&) (liftA2 (>=) date $pure t1) (liftA2 (<=) date $ pure t2)
