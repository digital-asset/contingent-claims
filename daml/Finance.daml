daml 1.2
module Finance where

import Prelude hiding (or,and)
import DA.Next.Set
import Recursion
import DA.Functor ((<&>))
import DA.Date (toDateUTC)

undefined = error "Undefined"
-- TODO replace with GenMap
type Map k v = [(k, v)]

-- E.g. FIGI
newtype SecurityId = SecurityId Text
  deriving (Show, Eq)

template MasterServiceAgreement with
    -- Counterparties
    buyer: Party
    seller: Party
    marketDataProvider: Party
    -- Standard contracts
  where
    signatory buyer, seller
    controller buyer can 
      Execute: ContractId Contract with obligations: Obligation  -- needs propose/accept workflow
        do 
           now <- getTime <&> toDateUTC
           create Contract with buyer, seller, obligations, asAt = now

template Contract with
    buyer: Party
    seller: Party
    -- id: SecurityId -- The FIGI of the security if it's not OTC
    obligations: Obligation -- of the buyer
    asAt: Date
    -- dayConvention
  where
    signatory buyer, seller
    controller buyer can 
      Lifecycle: ContractId Contract with 
        t: Date
        election: Obligation
          do undefined
        -- fold until the given date, 
  
    --choice Underlyings -- get set of underlying

{-
template Election with
    buyer: Party
    electionDate: Date
    election: Bool
    verbatim: Text
  where signatory buyer
-}

-- | In Petyon-Jones' paper, this is called 'Contract'.
-- We renamed it to allow our top-level (template) to be Contract.
data Obligation = Zero
  | One Currency -- Does this need to be parametrized? Otherwise this only works for cash-settled securities.
  | Give Obligation -- consider using Swap as a primitive instead of (one-sided) give.
  | And with lhs: Obligation, rhs: Obligation
  | Or with lhs: Obligation, rhs: Obligation
  | Cond with predicate: (Obs Bool), tru: Obligation, fls: Obligation
  | Scale with k: (Obs Decimal), x: Obligation -- TODO: Decimal -> Numeric ? 
  | When with o: (Obs Bool), x: Obligation
  | Anytime with o: (Obs Bool), x: Obligation
  | Until with o: (Obs Bool), x: Obligation
  deriving (Show, Eq)

-- | pattern functor, for internal use only.
data ObligationF a = ZeroF 
  | OneF Currency 
  | GiveF a
  | AndF with lhs: a, rhs: a
  | OrF with lhs: a, rhs: a
  | CondF with predicate: (Obs Bool), tru: a, fls: a
  | ScaleF with k: (Obs Decimal), x: a
  | WhenF with o: (Obs Bool), x: a
  | AnytimeF with o: (Obs Bool), x: a
  | UntilF with o: (Obs Bool), x: a
  deriving (Show, Eq, Functor)

instance Recursive Obligation ObligationF where
  project Zero = ZeroF
  project (One x) = OneF x
  project (Give a) = GiveF a
  project (And a b) = (AndF a b)
  project (Or a b) = (OrF a b)
  project (Cond x a b) = CondF x a b
  project (Scale k x) = ScaleF k x
  project (When o x) = WhenF o x
  project (Anytime o x) = AnytimeF o x
  project (Until o x) = UntilF o x

-- | A future value which may or may not have been observed yet.
-- Typically `Date` or `Decimal`. 
-- These include a number of common operators prefixed with percent sign.
-- e.g.
-- %== equality
-- %<= less-than-or-equals
-- %&& boolean 'and'
-- etc.
--

-- TODO: really hate this encoding - is there a more elegant way to do this? 
-- The problem is that the output type is inferred from the inputs, so if we want e.g.
-- equality, we need to have ground input types, and then use a smart constructor that
-- explicitly states the output value.
data Obs a = Today
  | Const a
  | Spot with d: Date, id: SecurityId
  | ObsDtEq with dlhs: (Obs Date), drhs: (Obs Date)
  | ObsDtLte with dlhs: (Obs Date), drhs: (Obs Date)
  | ObsREq with rlhs: (Obs Decimal), rrhs: (Obs Decimal)
  | ObsRLte with rlhs: (Obs Decimal), rrhs: (Obs Decimal)
  | ObsPlus with lhs: (Obs a), rhs: (Obs a)
  | ObsTimes with lhs: (Obs a), rhs: (Obs a)
  | ObsPow with lhs: (Obs a), i: Int
  | ObsAnd with blhs: (Obs Bool), brhs: (Obs Bool)
  | ObsOr with blhs: (Obs Bool), brhs: (Obs Bool)
  | ObsNeg with blhs: (Obs Bool)
    deriving (Show, Eq)

class {- (Ordering a) => -} ObsOrdering a where
  (%==) : Obs a -> Obs a -> Obs Bool
  (%/=) : Obs a -> Obs a -> Obs Bool
  (%/=) a a' = (%!) (a %== a')
  (%<=) : Obs a -> Obs a -> Obs Bool
  (%<) : Obs a -> Obs a -> Obs Bool
  (%<) a a' = (a %<= a') %&& (a %/= a')
  (%>) : Obs a -> Obs a -> Obs Bool
  (%>) a a' = (%!) (a %<= a')
  (%>=) : Obs a -> Obs a -> Obs Bool
  (%>=) a a' = (a %> a') %|| (a %== a')


instance ObsOrdering Date where
  (%==) = ObsDtEq
  (%<=) = ObsDtLte

instance ObsOrdering Decimal where
  (%==) = ObsREq
  (%<=) = ObsRLte

(%&&) : Obs Bool -> Obs Bool -> Obs Bool
(%&&) = ObsAnd

(%||) : Obs Bool -> Obs Bool -> Obs Bool
(%||) = ObsOr

(%!) : Obs Bool -> Obs Bool
(%!) = ObsNeg

instance Additive (Obs Decimal) where
  aunit = konst 0.0
  o + o' = ObsPlus o o'

instance Multiplicative (Obs Decimal) where
  munit = konst 1.0
  o * o' = ObsTimes o o'
  x ^ i = ObsPow x i

instance Number (Obs Decimal) where

template MarketData with
    source: Party
    subscribers: Set Party
  where 
    signatory source
    controller subscribers can  
      Close: Decimal with d: Date
        do undefined

zero = Zero

one ccy = One ccy

give c = Give c

and c1 c2 = And c1 c2

or c1 c2 = Or c1 c2

cond p c1 c2 = Cond p c1 c2

scale k c1 = Scale k c1

when o c1 = When o c1

anytime o c1 = Anytime o c1

until o c1 = Until o c1

data Currency = GBP | USD -- Generalize this to any 'asset'
  deriving (Show, Eq)

zcb : Date -> Decimal -> Currency -> Obligation 
zcb maturity payoff ccy = 
  when (at maturity) $ scale (konst payoff) (one ccy)

konst : a -> Obs a
konst a = Const a

at : Date -> Obs Bool
at t = today %== (konst t)

today : Obs Date
today = Today

european : Date -> Obligation -> Obligation
european t u = when (at t) (u `or` zero)

american : (Date, Date) -> Obligation -> Obligation
american (t1, t2) u = anytime (between t1 t2) u

between : Date -> Date -> Obs Bool
between t1 t2 = (today %>= konst t1) %&& (today %<= konst t2)
