--
-- Copyright (c) 2021, Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0
--

{-# LANGUAGE MultiWayIf #-}
{-# OPTIONS -Wno-deprecations #-} -- To supress 'Monad' warnings

module ContingentClaims.Lifecycle (
    lifecycle
  , lifecycle'
  , Result(..)
) where

import ContingentClaims.Claim (Claim, Claim(..), ClaimF(..))
import ContingentClaims.Observation (Observation, eval)
import Daml.Control.Recursion (para)
import Daml.Control.Monad.Writer (WriterT, runWriterT)
import Daml.Control.Monad.Reader (ReaderT(..), runReaderT)
import Daml.Control.Monad.MonadReader (MonadReader(..))
import Daml.Control.Monad.MonadWriter (MonadWriter(..))
import Daml.Control.Monad.Trans
import Daml.Control.Arrow (Kleisli(..))
import Prelude hiding (sequence, mapA)
import DA.Functor (($>))

type C a = Claim Observation Date a
type F a = ClaimF Observation Date a

deriving instance Eq a => Eq (C a)

-- | Returned from a lifecycle operation.
data Result a = Result with
  remaining : C a
    -- ^ the tree after lifecycled branches have been pruned.
  pending : [(Decimal, a)]
    -- ^ quantity/asset pairs requiring settlement.

-- | Lifecycle a Claim. Parameters:
-- 1. Function taking key and date, used to lookup an observable on the ledger. `m` will typically be `Update`. It is parametrised so it can be run in a `Script`.
-- 2. Function used when branching in an `Or`. Must return one of the arguments.
-- 3. A set of `Claim`s.
-- 4. A function which, given a date, lifecycles the third argument.
lifecycle : (Eq a, CanAbort m)
  => (Text -> Date -> m Decimal)
  -> (C a -> C a -> C a)
  -> C a
  -> Date -> m (Result a)
lifecycle spot choose
  = runKleisli
  . fmap (uncurry Result)
  . flip runReaderT 1.0
  . runWriterT
  . para (lifecycle' spot choose)

type Seed m a = WriterT [(Decimal, a)] (ReaderT Decimal (Kleisli m Date)) (C a)

-- TODO: these three should probably go in their respective modules

instance (Monoid w, CanAbort m) => CanAbort (WriterT w m) where
  abort = lift . abort

instance CanAbort m => CanAbort (ReaderT s m) where
  abort = lift . abort

instance CanAbort m => CanAbort (Kleisli m a) where -- because of the order of parameters it's not possible to write a MonadTrans instance for Kleisli.
  abort = Kleisli . const . abort

lifecycle' : (Eq a, Monad m, CanAbort m)
  => (Text -> Date -> m Decimal)
  -> (C a -> C a -> C a)
  -> F a (C a, Seed m a) -> Seed m a

lifecycle' _ _ ZeroF = pure Zero
lifecycle' _ _ (OneF id) = do
  qty <- ask
  tell [(qty, id)]
  pure $ One id
lifecycle' _ _ (GiveF (_, m)) = local negate m
lifecycle' spot _ (WhenF obs (c, m)) = do
  wasLifecycled <- lift . lift $ eval spot obs
  if wasLifecycled then m $> Zero else pure $ When obs c
lifecycle' spot _ (ScaleF obs (_, m)) = do
  k <- lift . lift $ eval spot obs
  local (* k) m
lifecycle' _ choose (OrF (c, m) (c', m')) = do
  let chosen = choose c c'
  if | chosen == c -> m
     | chosen == c' -> m'
     | otherwise -> abort "lifecycle: Invalid branch election"
lifecycle' _ _ (AndF (_, m) (_, m')) = reduceZero <$> m <*> m' where
   reduceZero Zero c' = c'
   reduceZero c Zero = c
   reduceZero c c' = And c c'
lifecycle' spot _ (CondF obs (_, m) (_, m')) = do
  predicate <- lift . lift $ eval spot obs
  if predicate then m else m'
