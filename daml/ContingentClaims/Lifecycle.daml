--
-- Copyright (c) 2021, Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0
--

{-# OPTIONS -Wno-deprecations #-} -- To supress 'Monad' warnings

module ContingentClaims.Lifecycle (
    settle
  , settle'
  , acquire'
  , acquireThenSettle
  , Result(..)
) where

import ContingentClaims.Claim (Claim, Claim(..), ClaimF(..))
import ContingentClaims.Observation (Observation, eval)
import ContingentClaims.Util (apoCataM, pruneZeros')
import Daml.Control.Recursion (project, embed, distApo)
import Daml.Control.Monad.Writer (WriterT, runWriterT)
import Daml.Control.Monad.MonadWriter (MonadWriter(..))
import Daml.Control.Monad.Trans
import Daml.Control.Arrow (Kleisli(..))
import DA.Traversable (sequence)
import DA.Foldable (sequence_)
import Prelude hiding (sequence, mapA)

type C a = Claim Observation Date a
type F a = ClaimF Observation Date a

deriving instance Eq a => Eq (C a)

-- | Returned from a `settle` operation.
data Result a = Result with
  remaining : C a
    -- ^ the tree after lifecycled branches have been pruned.
  pending : [(Decimal, a)]
    -- ^ quantity/asset pairs requiring settlement.

-- | Collect claims falling due into a list, and return the tree with those nodes pruned.
-- `m` will typically be `Update`. It is parametrised so it can be run in a `Script`.
-- The first argument is used to lookup the value of any `Observables`.
-- Results in a function taking today's date, and returning the pruned tree + pending settlements.
settle : (Eq a, CanAbort m)
  => (Text -> Date -> m Decimal)
  -> C a
  -> Date -> m (Result a)
settle spot
  = runKleisli
  . fmap (uncurry Result)
  . runWriterT
  . apoCataM pruneZeros' (acquireThenSettle spot)
  . (1.0, )

acquireThenSettle : (CanAbort m, Eq a) 
                  => (Text -> Date -> m Decimal) 
                  -> (Decimal, C a) -> WriterT [(Decimal, a)] (Kleisli m Date) (F a (Either (C a) (Decimal, C a)))
acquireThenSettle spot = 
  fmap (fmap distE)
  . fmap join
  . fmap (fmap sequence)
  . fmap (fmap (fmap (settle' spot)))
  . fmap (fmap sequence)
  . fmap sequence
  . fmap
  . fmap (fmap (fmap embed))
  . fmap (fmap (tsidE : F a (Either (C a) (C a)) -> Either (C a) (F a (C a)) ))
  . fmap lift
  $ acquire' spot
  where distE = distApo
         -- This is degenerate if you have e.g. `And Left Right`, but that should never happen in practice.
        tsidE f = case sequence_ f of 
          Left _ -> Left (embed (fmap foldE f))
          Right _ -> Right (fmap foldE f)
        foldE (Left x) = x
        foldE (Right x) = x

-- | Evaluate observables and skip branches for which predicates don't hold.
-- This is useless on its own. Composed with other functions it adds laziness.
acquire' : (Eq a, Monad m)
  => (Text -> Date -> m Decimal)
  -> C a -> Kleisli m Date (F a (Either (C a) (C a)))
acquire' spot (When obs c) = do
  predicate <- eval spot obs
  if predicate then acquire' spot c else pure $ WhenF obs (Left c)
acquire' spot (Cond obs c c') = do
  predicate <- eval spot obs
  if predicate then acquire' spot c else acquire' spot c'
acquire' _ other = pure $ Right <$> project other

-- | Collects all `One` leaves replacing them with `Zero`s (to avoid double-spend).
-- Calculates the product of any `Scale` factors between each `One` and the root node, logging these to the writer.
-- This function **ignores** conditions; it traverses the entire tree.
settle' : CanAbort m 
        => (Text -> Date -> m Decimal) 
        -> (Decimal, C a) -> WriterT [(Decimal, a)] (Kleisli m Date) (F a (Decimal, C a))
settle' _ (qty, One asset) = do
  tell [(qty, asset)]
  pure ZeroF
settle' _ (qty, Give c) = 
  pure $ GiveF (-qty, c)
settle' spot (qty, Scale obs c) = do
  k <- lift $ eval spot obs
  pure $ ScaleF obs (k * qty, c)
settle' _ (_, Or _ _) = abort "settle: unexercised `Or`. Exercise it and then retry. "
settle' _ (qty, other) = pure $ (qty, ) <$> project other

-- | Used to make an election on `Or` or exercise an `Anytime`.
--  `import` this `qualified`, to avoid clashes with `Prelude.exercise`.
exercise : (Text -> Date -> m Decimal) -> C a -> C a -> Date -> C a
exercise = undefined

-- | Coalgebra for `exercise`.
exercise' : Eq a => C a -> C a -> F a (C a)
exercise' chosen (Or c _) | chosen == c = project c
exercise' chosen (Or _ c) | chosen == c = project c
exercise' chosen (Anytime _ c) | chosen == c = project c
exercise' _ other = project other

-- | Replace any subtress that have expired with `Zero`s.
expire : Monad m => (Text -> Date -> m Decimal) -> C a -> m (C a)
expire spot = apoCataM pruneZeros' undefined

-- | Coalgebra for `expire`.
expire' : Monad m => (Text -> Date -> m Decimal) -> C a -> Kleisli m Date (F a (C a))
expire' spot (Until obs c) = do
  predicate <- eval spot obs
  if predicate then pure ZeroF else pure $ UntilF obs c
expire' _ (One _) = pure ZeroF
expire' _ other = pure . project $ other
