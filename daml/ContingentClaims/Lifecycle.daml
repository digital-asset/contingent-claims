--
-- Copyright (c) 2021, Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0
--

{-# OPTIONS -Wno-deprecations #-} -- To supress 'Monad' warnings

module ContingentClaims.Lifecycle (
    settle
  , settle'
  , acquire'
  , exercise
  , exercise'
  , Result(..)
) where

import ContingentClaims.Claim (Claim, Claim(..), ClaimF(..))
import ContingentClaims.Observation (Observation, eval)
import ContingentClaims.Util (apoCataM, pruneZeros')
import Daml.Control.Recursion (project, embed, distApo)
import Daml.Control.Monad.Writer (WriterT, runWriterT)
import Daml.Control.Monad.MonadWriter (MonadWriter(..))
import Daml.Control.Monad.Trans
import Daml.Control.Arrow (Kleisli(..))
import DA.Traversable (sequence)
import DA.Foldable (sequence_)
import Prelude hiding (sequence, mapA, exercise)

type C a = Claim Observation Date a
type F a = ClaimF Observation Date a

deriving instance Eq a => Eq (C a)

-- | Returned from a `settle` operation.
data Result a = Result with
  remaining : C a
    -- ^ the tree after lifecycled branches have been pruned.
  pending : [(Decimal, a)]
    -- ^ quantity/asset pairs requiring settlement.

-- | Collect claims falling due into a list, and return the tree with those nodes pruned.
-- `m` will typically be `Update`. It is parametrised so it can be run in a `Script`.
-- The first argument is used to lookup the value of any `Observables`.
-- Results in a function taking today's date, and returning the pruned tree + pending settlements.
settle : (Eq a, CanAbort m)
  => (Text -> Date -> m Decimal)
  -> C a
  -> Date -> m (Result a)
settle spot
  = runKleisli
  . fmap (uncurry Result)
  . runWriterT
  . apoCataM pruneZeros' acquireThenSettle
  . (1.0, )
  where
    acquireThenSettle = 
      fmap (fmap (fmap join))
      . fmap (fmap distE)
      . fmap join
      . fmap (fmap sequence)
      . fmap (fmap (fmap (settle' spot)))
      . fmap (fmap sequence)
      . fmap sequence
      . fmap
      . fmap (fmap (fmap embed))
      . fmap (fmap (tsidE : F a (Either (C a) (C a)) -> Either (C a) (F a (C a)) ))
      . fmap lift
      $ acquire' spot
    distE = distApo
     -- This is degenerate if you have e.g. `And Left Right`, but that should never happen in practice.
    tsidE f = case sequence_ f of 
      Left _ -> Left (embed (fmap foldE f))
      Right _ -> Right (fmap foldE f)
    foldE (Left x) = x
    foldE (Right x) = x

-- | Evaluate observables and skip branches for which predicates don't hold.
-- Consumes `When` and `Cond` when appropriate, leaving their subtrees.
-- This is useless on its own. Composed with other functions, it adds laziness.
acquire' : (Eq a, Monad m)
  => (Text -> Date -> m Decimal)
  -> C a -> Kleisli m Date (F a (Either (C a) (C a)))
acquire' spot (When obs c) = do
  predicate <- eval spot obs
  if predicate then acquire' spot c else pure $ WhenF obs (Left c)
acquire' spot (Cond obs c c') = do
  predicate <- eval spot obs
  if predicate then acquire' spot c else acquire' spot c'
acquire' spot (Anytime obs c) = do
  predicate <- eval spot obs
  pure $ AnytimeF obs if predicate then Right c else Left c
acquire' spot (Until obs c) = do
  predicate <- eval spot obs
  pure $ UntilF obs if predicate then Left c else Right c
acquire' _ other = pure $ Right <$> project other

-- | Evaluate any observables in `Scale` nodes, accumulating scale factors
-- top-down, and log these with their corresponding leaf values. Skip `Or` and
-- `Anytime` branches.
settle' : CanAbort m 
        => (Text -> Date -> m Decimal) 
        -> (Decimal, C a) -> WriterT [(Decimal, a)] (Kleisli m Date) (F a (Either (C a) (Decimal, C a)))
settle' _ (qty, One asset) = do
  tell [(qty, asset)]
  pure $ Right <$> ZeroF
settle' _ (qty, Give c) = 
  pure . GiveF $ Right (-qty, c)
settle' spot (qty, Scale obs c) = do
  k <- lift $ eval spot obs
  pure . ScaleF obs $ Right (k * qty, c)
settle' _ (_, c@(Or _ _)) = pure $ Left <$> project c
settle' _ (_, c@(Anytime _ _)) = pure $ Left <$> project c
settle' _ (qty, other) = pure $ Right . (qty, ) <$> project other

data ExerciseResult a = ExerciseResult with party: Party, remaining: C a

--  | Acquire `Anytime` and `Or` nodes, by making an election.
-- `import` this `qualified`, to avoid clashes with `Prelude.exercise`.
exercise : (Eq a, Monad m) => (Text -> Date -> m Decimal) -> C a -> C a -> Date -> m (C a)
exercise spot election = runKleisli . apoCataM pruneZeros' acquireThenExercise where 
  acquireThenExercise = fmap (fmap distE) 
                        . fmap (fmap (fmap (exercise' election)) )
                        . fmap (fmap (fmap embed)) 
                        . fmap (fmap tsidE) 
                        $ acquire' spot
  distE = distApo
  tsidE f = case sequence_ f of 
    Left _ -> Left (embed (fmap foldE f))
    Right _ -> Right (fmap foldE f)
  foldE (Left x) = x
  foldE (Right x) = x

-- | Coalgebra for `exercise`.
exercise' : Eq a => C a -> C a -> F a (C a)
exercise' chosen (Or c _) | chosen == c = project c
exercise' chosen (Or _ c) | chosen == c = project c
exercise' chosen (Anytime _ c) | chosen == c = project c
exercise' _ other = project other

-- | Replace any subtress that have expired with `Zero`s.
expire : Monad m => (Text -> Date -> m Decimal) -> C a -> m (C a)
expire spot = apoCataM pruneZeros' undefined

-- | Coalgebra for `expire`.
expire' : Monad m => (Text -> Date -> m Decimal) -> C a -> Kleisli m Date (F a (C a))
expire' spot (Until obs c) = do
  predicate <- eval spot obs
  if predicate then pure ZeroF else pure $ UntilF obs c
expire' _ (One _) = pure ZeroF
expire' _ other = pure . project $ other
