-- Copyright (c) 2022 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

{-# OPTIONS -Wno-deprecations #-} -- To supress 'Monad' warnings

module ContingentClaims.Lifecycle (
    lifecycle
  , lifecycle'
  , acquire'
  , exercise
  , exercise'
  , expire
  , Result(..)
) where

import ContingentClaims.Claim (Claim, Claim(..), ClaimF(..), compare, Inequality(..))
import ContingentClaims.Observation qualified as Observation
import ContingentClaims.Util.Recursion (apoCataM)
import ContingentClaims.Util (pruneZeros')
import Daml.Control.Recursion (project, embed, distApo)
import Daml.Control.Monad.Trans.Writer (WriterT, runWriterT)
import Daml.Control.Monad.Writer.Class (MonadWriter(..))
import Daml.Control.Monad.Trans.Class (lift)
import Daml.Control.Arrow (Kleisli(..))
import DA.Traversable (sequence)
import DA.Foldable (sequence_, elem)
import Prelude hiding (sequence, mapA, exercise, compare, elem)

type C t a = Claim t Decimal a
type F t a = ClaimF t Decimal a

-- | Returned from a `lifecycle` operation.
data Result t a = Result with
  pending : [(Decimal, a)]
    -- ^ quantity/asset pairs requiring settlement.
  remaining : C t a
    -- ^ the tree after lifecycled branches have been pruned.

-- | Collect claims falling due into a list, and return the tree with those nodes pruned.
-- `m` will typically be `Update`. It is parametrised so it can be run in a `Script`.
-- The first argument is used to lookup the value of any `Observables`.
-- Results in a function taking today's date, and returning the pruned tree + pending settlements.
lifecycle : (Ord t, Eq a, CanAbort m)
  => (a -> t -> m Decimal)
  -- ^ function to evaluate observables 
  -> t
  -- ^ start date of the input claim
  -> C t a
  -- ^ the input claim
  -> t
  -- ^ the today's date
  -> m (Result t a)
lifecycle spot startDate
  = runKleisli
  . fmap (uncurry $ flip Result)
  . runWriterT
  . apoCataM pruneZeros' acquireThenSettle
  . ((startDate, 1.0), )
  where
    acquireThenSettle =
      fmap (fmap (fmap join))
      . fmap (fmap distE)
      . fmap join
      . fmap (fmap sequence)
      . fmap (fmap (fmap (lifecycle' spot)))
      . fmap (fmap sequence)
      . fmap sequence
      . fmap
      . fmap (fmap (fmap embed))
      . fmap (fmap (tsidE : F t a (Either (C t a) (C t a)) -> Either (C t a) (F t a (C t a)) ))
      . fmap lift
      $ acquire' spot
    distE = distApo
     -- This is degenerate if you have e.g. `And Left Right`, but that should never happen in practice.
    tsidE f = case sequence_ f of
      Left _ -> Left (embed (fmap foldE f))
      Right _ -> Right (fmap foldE f)
    foldE (Left x) = x
    foldE (Right x) = x

-- | Evaluate observables and skip branches for which predicates don't hold.
-- This is useless on its own. Composed with other functions, it adds laziness.
acquire' : (Ord t, Eq a, Monad m)
  => (a -> t -> m Decimal)
  -> C t a -> Kleisli m t (F t a (Either (C t a) (C t a)))
acquire' spot (When obs c) = do
  predicate <- compare spot obs
  pure $ WhenF obs if predicate then Right c else Left c
acquire' spot (Cond obs c c') = do
  predicate <- compare spot obs
  pure if predicate 
    then CondF obs (Right c) (Left c') 
    else CondF obs (Left c) (Right c')
acquire' spot (Anytime obs c) = do
  predicate <- compare spot obs
  pure $ AnytimeF obs if predicate then Right c else Left c
acquire' _ other = pure $ Right <$> project other

-- | Evaluate any observables in `Scale` nodes, accumulating scale factors and 
-- propagating the claim's acquisition times top-down.
-- Log the scale factors with their corresponding leaf values. 
-- Skip `Or` and `Anytime` branches, guaranteeing liveness. 
-- Replace any Ones that can be reached with Zeros.
lifecycle' : (Ord t, CanAbort m)
        => (a -> t -> m Decimal)
        -> ((t, Decimal), C t a) -> WriterT [(Decimal, a)] (Kleisli m t) (F t a (Either (C t a) ((t, Decimal), C t a)))
lifecycle' _ ((_, qty), One asset) = do
  tell [(qty, asset)]
  pure $ Right <$> ZeroF
lifecycle' _ ((s, qty), Give c) =
  pure . GiveF $ Right ((s, -qty), c)
lifecycle' spot ((s, qty), Scale obs c) = do
  k <- lift $ Kleisli \ _ -> runKleisli (Observation.eval spot obs) s
  -- ^ evaluates the observable at the contract's acquisition time
  pure . ScaleF obs $ Right ((s, k * qty), c)
lifecycle' _ (_, c@Or{}) = pure $ Left <$> project c
lifecycle' _ (_, c@(Anytime _ _)) = pure $ Left <$> project c
lifecycle' _ ((s, qty), When cond c) = do
  let acquisitionTime t = case cond of
        (TimeGte tau) -> max tau s
        -- TimeGte tau becomes True exactly at time t = tau
        other -> t
        -- in all other cases, we assume that we are lifecycling at a time `t` corresponding to the first instant the condition becomes True
  lift $ Kleisli \t -> pure $ WhenF cond $ Right ((acquisitionTime t, qty), c)
lifecycle' _ ((s, qty), other) = pure $ Right . ((s, qty), ) <$> project other


--  | Acquire `Anytime` and `Or` nodes, by making an election.
-- `import` this `qualified`, to avoid clashes with `Prelude.exercise`.
exercise : (Ord t, Eq a, Monad m) => (a -> t -> m Decimal) -> (Bool, C t a) -> C t a -> t -> m (C t a)
exercise spot election = runKleisli . apoCataM pruneZeros' acquireThenExercise . (True, ) where
  acquireThenExercise = fmap (fmap (fmap join))
                        . fmap (fmap distE)
                        . fmap (fmap (fmap (exercise' election)))
                        . fmap (fmap sequence)
                        . fmap sequence . fmap
                        . fmap (fmap (fmap embed))
                        . fmap (fmap tsidE)
                        $ acquire' spot
  distE = distApo
  tsidE f = case sequence_ f of
    Left _ -> Left (embed (fmap foldE f))
    Right _ -> Right (fmap foldE f)
  foldE (Left x) = x
  foldE (Right x) = x

-- | Coalgebra for `exercise`.
-- Resolves `Or` and `Anytime` nodes by removing them (keeping elected subtrees).
-- The election consists of a boolean representing the authorizer (`True = bearer`),
-- and this is compared against available branches of the choice.
exercise' : (Eq t, Eq a) => (Bool, C t a) -> (Bool, C t a) -> (F t a (Either (C t a) (Bool, C t a)))
exercise' _ (isBearer, Give c) = GiveF . Right $ (not isBearer, c)
exercise' (elector, election) (isBearer, ors@Or {}) | elector /= isBearer = Left <$> project ors 
                                                    | election `elem` project ors = Right . (isBearer,) <$> project election 
                                                    | otherwise = Left <$> project ors 
exercise' (elector, election) (isBearer, f@(Anytime _ c)) =
  if elector == isBearer && election == c then Right . (isBearer, ) <$> project c
                                          else Left <$> project f
exercise' _ (isBearer, other) = Right . (isBearer, ) <$> project other

-- | Replace any subtrees that have expired with `Zero`s.
expire : (Ord t, Eq a, Monad m) => (a -> t -> m Decimal) -> C t a -> t -> m (C t a)
expire spot = runKleisli . apoCataM pruneZeros' acquireThenExpire where
  acquireThenExpire = fmap (fmap distE)
                      . fmap join
                      . fmap (fmap sequence)
                      . fmap (fmap (fmap (expire' spot)))
                      . fmap (fmap (fmap embed))
                      . fmap (fmap tsidE)
                      $ acquire' spot
  distE = distApo
  tsidE f = case sequence_ f of
    Left _ -> Left (embed (fmap foldE f))
    Right _ -> Right (fmap foldE f)
  foldE (Left x) = x
  foldE (Right x) = x

-- | Coalgebra for `expire`.
expire' : (Ord t, Monad m) => (a -> t -> m Decimal) -> C t a -> Kleisli m t (F t a (C t a))
expire' spot (Until obs c) = do
  predicate <- compare spot obs
  if predicate then pure ZeroF else pure $ UntilF obs c
expire' _ other = pure . project $ other
