-- Copyright (c) 2022 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

{-# OPTIONS -Wno-deprecations #-} -- To supress 'Monad' warnings

module ContingentClaims.Lifecycle (
    lifecycle
  , lifecycle'
  , acquire'
  , exercise
  , exercise'
  , expire
  , Result(..)
) where

import ContingentClaims.Claim (Claim, Claim(..), ClaimF(..), compare, Inequality(..))
import ContingentClaims.Observation qualified as Observation
import ContingentClaims.Util.Recursion (apoCataM)
import ContingentClaims.Util (pruneZeros', intrinsicAcquisitionTime)
import Daml.Control.Recursion (project, distApo)
import Daml.Control.Monad.Trans.Writer (WriterT, runWriterT)
import Daml.Control.Monad.Writer.Class (MonadWriter(..))
import Daml.Control.Monad.Trans.Class (lift)
import DA.Traversable (sequence)
import DA.Foldable (elem)
import DA.Optional (fromSomeNote)
import Prelude hiding (sequence, mapA, exercise, compare, elem)

type C t a = Claim t Decimal a
type F t a = ClaimF t Decimal a

-- | Returned from a `lifecycle` operation.
data Result t a = Result with
  pending : [(Decimal, a)]
    -- ^ quantity/asset pairs requiring settlement.
  remaining : C t a
    -- ^ the tree after lifecycled branches have been pruned.
    deriving (Eq, Show)

-- | Collect claims falling due into a list, and return the tree with those nodes pruned.
-- `m` will typically be `Update`. It is parametrised so it can be run in a `Script`.
-- The first argument is used to lookup the value of any `Observables`.
-- Results in a function taking today's date, and returning the pruned tree + pending settlements.
lifecycle : (Ord t, Eq a, CanAbort m)
  => (a -> t -> m Decimal)
  -- ^ function to evaluate observables 
  -> C t a
  -- ^ the input claim
  -> t
  -- ^ the today's date
  -> m (Result t a)
lifecycle spot claim today
  = fmap (uncurry $ flip Result)
  . runWriterT
  . apoCataM pruneZeros' acquireThenSettle
  . (1.0, ) -- initial scaling factor
  $ (acquisitionTime, claim)
  where
    acquireThenSettle =
      fmap (fmap (fmap join))
      . fmap (fmap distE)
      . fmap join
      . fmap (fmap sequence)
      . fmap (fmap (fmap (lifecycle' spot)))
      . fmap (fmap sequence)
      . fmap sequence
      . fmap
      . fmap lift
      $ acquire' spot today
    distE = distApo
    acquisitionTime = fromSomeNote "Claim does not have an intrinsic acquisition time" $ intrinsicAcquisitionTime claim

-- | Evaluate observables and skip branches for which predicates don't hold, calculate the acquisition time of the claim's sub-trees.
-- Consume `Cond` nodes, leaving the relevant sub-tree.
-- Replace `When pred c` nodes with `When (TimeGte t) c` if the predicate is non-deterministic and evaluates to True.
-- This is useless on its own. Composed with other functions, it adds laziness.
acquire' : (Ord t, Eq a, CanAbort m)
  => (a -> t -> m Decimal)
  -- ^ function to evaluate observables 
  -> t
  -- ^ the today date
  -> (t, C t a)
  -- ^ input claim and its acquisition time
  -> m (Either (C t a) (t, C t a))
acquire' spot t (s, (When obs c)) = do
  predicate <- compare spot obs t
  if predicate then
    case obs of
      TimeGte sNew -> pure $ Right . (max s sNew, ) $ When obs c
      other -> pure $ Right . (t, ) $ When (TimeGte t) c  -- if the predicate is non-deterministic, we assume that we are lifecycling at a time `t` corresponding to the first instant the predicate becomes True
    else
      pure . Left $ When obs c
acquire' spot today (s,(Cond obs c c')) = do
  predicate <- compare spot obs s
  if predicate 
    then acquire' spot today (s,c)
    else acquire' spot today (s,c')
acquire' spot today (_,c@(Anytime obs _)) = do
  predicate <- compare spot obs today
  pure $ if predicate then Right (today,c) else Left c  -- the acquisition time of a subcontract of `Anytime` is assumed to be the time at which we lifecycle
acquire' _ _ (s,other) = pure $ Right (s, other)

-- | Evaluate any observables in `Scale` nodes, accumulating scale factors top-down.
-- Log the scale factors with their corresponding leaf values. 
-- Skip `Or` and `Anytime` branches, guaranteeing liveness. 
-- Replace any Ones that can be reached with Zeros.
lifecycle' : (Ord t, CanAbort m)
        => (a -> t -> m Decimal)
        -> (Decimal, (t, C t a))
        -- ^ the input claim, the acquisition time of its sub-trees and the accumulated scaling factor
        -> WriterT [(Decimal,a)] m (F t a (Either (C t a) ((Decimal, (t, C t a)))))
lifecycle' _ (qty, (_, One asset)) = do
  tell [(qty, asset)]
  pure $ Right <$> ZeroF
lifecycle' _ (qty, (s, Give c)) =
  pure . GiveF $ Right (-qty, (s, c))
lifecycle' spot (qty, (s, Scale obs c)) = do
  k <- lift $ Observation.eval spot obs s
  pure . ScaleF obs $ Right (k * qty, (s, c))
lifecycle' _ (_, (_, c@Or{})) = pure $ Left <$> project c
lifecycle' _ (_, (_, c@(Anytime _ _))) = pure $ Left <$> project c
lifecycle' _ (qty, (s, other)) = pure $ Right . (qty, ) . (s, ) <$> project other

--  | Acquire `Anytime` and `Or` nodes, by making an election.
-- `import` this `qualified`, to avoid clashes with `Prelude.exercise`.
exercise : (Ord t, Eq a, CanAbort m)
  => (a -> t -> m Decimal)
  -- ^ function to evaluate observables 
  -> (Bool, C t a)
  -- ^ the election being made
  -> C t a
  -- ^ the input claim
  -> t
  -- ^ the election date
  -> m (C t a)
exercise spot election claim today = 
  apoCataM pruneZeros' acquireThenExercise
  . (True, ) -- initial election authorizer (`True = bearer`)
  $ (acquisitionTime, claim)
  where
    acquireThenExercise = fmap (fmap (fmap join))
                        . fmap (fmap distE)
                        . fmap (fmap (fmap (exercise' election today)))
                        . fmap (fmap sequence)
                        . fmap sequence . fmap
                        $ acquire' spot today
    distE = distApo
    acquisitionTime = fromSomeNote "Claim does not have an intrinsic acquisition time" $ intrinsicAcquisitionTime claim

-- | Coalgebra for `exercise`.
-- Resolves `Or` nodes by removing them (keeping elected subtrees).
-- Fixes acquisition time of exercised `Anytime` nodes by replacing them with `When (TimeGte t)`.
-- The election consists of a boolean representing the authorizer (`True = bearer`),
-- and this is compared against available branches of the choice.
exercise' : (Eq t, Eq a)
  => (Bool, C t a)
  -- ^ the election being made
  -> t
  -- ^ the election date
  -> (Bool, (t, C t a))
  -- ^ the input claim, its sub-trees acquisition time and a flag keeping track of who is the entitled to the election (`True = bearer`)
  -> (F t a (Either (C t a) (Bool, (t, C t a))))
exercise' _ _ (isBearer, (s, Give c)) = GiveF . Right . (not isBearer, ) $ (s, c)
exercise' (elector, election) t (isBearer, (s, ors@Or {}))
  | elector /= isBearer = Left <$> project ors
  | t /= s = Left <$> project ors
  | election `elem` project ors = Right . (isBearer,) . (s,) <$> project election
  | otherwise = Left <$> project ors
exercise' (elector, election) t (isBearer, (s, f@(Anytime _ c)))
  | elector /= isBearer = Left <$> project f
  | t /= s = Left <$> project f
  | election == c = Right . (isBearer, ) . (s,) <$> WhenF (TimeGte t) c
  | otherwise = Left <$> project f
exercise' _ _ (isBearer, (s, other)) = Right . (isBearer, ) . (s, ) <$> project other

-- | Replace any subtrees that have expired with `Zero`s.
expire : (Ord t, Eq a, CanAbort m) => (a -> t -> m Decimal) -> C t a -> t -> m (C t a)
expire spot claim today =
  apoCataM pruneZeros' acquireThenExpire
  $ (acquisitionTime, claim)
  where
    acquireThenExpire = fmap (fmap distE)
                      . fmap join
                      . fmap (fmap sequence)
                      . fmap (fmap (fmap (expire' spot today)))
                      $ acquire' spot today
    distE = distApo
    acquisitionTime = fromSomeNote "Claim does not have an intrinsic acquisition time" $ intrinsicAcquisitionTime claim

-- | Coalgebra for `expire`.
expire' : (Ord t, Monad m) => (a -> t -> m Decimal) -> t -> (t, C t a) -> m (F t a (t, C t a))
expire' spot t (s, Until obs c) = do
  predicate <- compare spot obs t
  if predicate then pure ZeroF else pure $ UntilF obs (s, c)
expire' _ _ (s, other) = pure $ (s, ) <$> project other
