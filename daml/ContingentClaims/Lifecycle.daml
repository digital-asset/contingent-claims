module ContingentClaims.Lifecycle (
    lifecycle
  , lifecycle'
  , Result
) where

import ContingentClaims.Claim (Claim, Claim(..), ClaimF(..))
import ContingentClaims.Observation (Observation, eval)
import Daml.Control.Recursion
import Daml.Control.Monad.State (StateT, evalStateT)
import Daml.Control.Monad.Writer (WriterT, runWriterT)
import Daml.Control.Monad.MonadState (MonadState(..), modify)
import Daml.Control.Monad.MonadWriter (MonadWriter(..))
import Daml.Control.Monad.Trans
import Daml.Control.Arrow ((<<<),(>>>),(&&&), Kleisli(..))
import DA.Traversable (Traversable, sequence)
import Prelude hiding (sequence, mapA)

type C a = Claim Observation Date a
type F a = ClaimF Observation Date a

deriving instance Eq a => Eq (C a)

-- Returned from a lifecycle operation.
-- Remaining has the tree after lifecycled branches have been pruned.
-- Pending contains a list of quantity/asset pairs requiring settlement.
data Result a = Result with remaining: C a, pending : [(Decimal, a)]

-- @m@ will typically be @Update@. It is parametrised so it can be run in a @Script@.
-- Uses @spot@ to lookup spot prices.
-- Uses @choose@ to make an election during a branch
lifecycle : (Eq a, Monad m, CanAbort m)
  => (Text -> Date -> m Decimal)
  -> (C a -> C a -> C a)
  -> C a
  -> Date -> m (Result a)
lifecycle spot choose
  = runKleisli 
  . fmap (uncurry Result) 
  . flip evalStateT 1.0 
  . runWriterT 
  . cataM (lifecycle' spot choose)

-- TODO: these three might be more appropriate in daml-ctl/Recursion library.
cataM : (Monad m, Traversable f, Recursive b f) => (f a -> m a) -> b -> m a
cataM f b = (project >>> fmap (cataM f) >>> (>>= f) . sequence) b

paraM : (Monad m, Traversable f, Recursive b f) => (f (b, a) -> m a) -> b -> m a
paraM f b = (project >>> fmap (runKleisli $ Kleisli pure &&& Kleisli (paraM f)) >>> (>>= f) . sequence) b

anaM : (Monad m, Traversable f, Corecursive b f) => (a -> f (m a)) -> a -> m b
anaM f a = (fmap embed <<< sequence <<< fmap (>>= anaM f) <<< f) a

type Seed m a = WriterT [(Decimal, a)] (StateT Decimal (Kleisli m Date)) (C a)

-- TODO: these three should probably go in their respective modules

instance (Monoid w, CanAbort m) => CanAbort (WriterT w m) where
  abort = lift . abort

instance CanAbort m => CanAbort (StateT s m) where
  abort = lift . abort

instance CanAbort m => CanAbort (Kleisli m a) where -- because of the order of parameters it's not possible to write a MonadTrans instance for Kleisli.
  abort = Kleisli . const . abort

lifecycle' : (Eq a, Monad m, CanAbort m)
  => (Text -> Date -> m Decimal)
  -> (C a -> C a -> C a)
  -> F a (C a) -> Seed m a

lifecycle' _ _ ZeroF = pure Zero
lifecycle' _ _ (OneF id) = do
  qty <- get
  tell [(qty, id)]
  pure Zero -- this is is sort of redundant as `When` prunes nodes too.
lifecycle' _ _ (GiveF c) = do
  modify negate
  pure $ Give c
lifecycle' spot _ (WhenF obs c) = do
  wasLifecycled <- lift . lift $ eval spot obs
  if wasLifecycled then pure Zero else pure $ When obs c
lifecycle' spot _ (ScaleF obs c) = do
  k <- lift .lift $ eval spot obs
  modify (* k) 
  pure $ Scale obs c
lifecycle' _ choose (OrF c c') = do
  let chosen = choose c c'
  assertMsg "lifecycle: Invalid branch election" $ chosen == c || chosen == c'
  pure chosen
lifecycle' _ _ (AndF Zero c) = pure c
lifecycle' _ _ (AndF c Zero) = pure c
lifecycle' _ _ (AndF c c') = pure $ And c c'
lifecycle' spot _ (CondF obs c c') = do
  predicate <- lift . lift $ eval spot obs
  if predicate then pure c else pure c'
