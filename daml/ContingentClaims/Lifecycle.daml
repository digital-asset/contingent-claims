{-# LANGUAGE MultiWayIf #-}

module ContingentClaims.Lifecycle (
    lifecycle
  , lifecycle'
  , pruneLeaf
  , pruneLeaf'
  , pruneOr
  , pruneOr'
) where

import ContingentClaims.Claim (Claim, Claim(..), ClaimF(..))
import ContingentClaims.Observation (Observation, eval)
import Daml.Control.Recursion
import Daml.Data.Profunctor
import Daml.Control.Monad.State (StateT)
import Daml.Control.Monad.MonadState (MonadState(..), modify)
import Daml.Control.Monad.Writer (WriterT)
import Daml.Control.Monad.MonadWriter (MonadWriter(..))
import Daml.Control.Monad.Trans (MonadTrans(..))
import Daml.Control.Arrow ((|||),(<<<),(>>>),(&&&), Kleisli(..))
import DA.Traversable (Traversable, mapA, sequence)
import Prelude hiding (sequence, mapA)

type C a = Claim Observation Date a
type F a = ClaimF Observation Date a

deriving instance Eq a => Eq (C a)

-- Returns a function that executes 'runSettl' on nodes that are 'current' at time t.
-- @m@ will typically be @Update@. It is parametrised so it can be run in a @Script@.
-- Uses @runSpot@ to lookup spot prices.
-- Uses @branch@ to make an election during a branch
lifecycle : (Eq a, Monad m)
  => (a -> Decimal -> Date -> m c)
  -> (Text -> Date -> m Decimal)
  -> (C a -> C a -> C a)
  -> C a
  -> Date -> m [c]
lifecycle runSettl runSpot branch claim = runKleisli (runKleisli (para (lifecycle' runSettl runSpot branch) claim) 1.0)

type Orders = [(Decimal, Text)]
type Ctx = (Date, Decimal)
-- Date -> State (Writer (C a))
newtype ResultT m z = ResultT (StateT Ctx (WriterT Orders m) z)  deriving Functor

instance Applicative m => Applicative (ResultT m) where
  pure = undefined
  (<*>) = undefined

instance Monad m => Action (ResultT m) where
  (>>=) = undefined

instance Monad m => MonadWriter Orders (ResultT m) where
  tell = undefined
  listen = undefined
  pass = undefined

instance Monad m => MonadState Ctx (ResultT m) where
  state = undefined

instance MonadTrans ResultT where
  lift = undefined

-- instance MonadState s (ResultT m) where

runResultT : ResultT m (C a) -> Date -> ([(Decimal, a)], C a)
runResultT = undefined

{- seqResultT : (Functor f, Monad m) => Date -> ResultT m (f z) -> f (ResultT m z)
seqResultT t (ResultT g)  =   -}

cataM : (Monad m, Traversable f, Recursive b f) => (f a -> m a) -> b -> m a
cataM f b = (project >>> fmap (cataM f) >>> (>>= f) . sequence) b

paraM : (Monad m, Traversable f, Recursive b f) => (f (b, a) -> m a) -> b -> m a
paraM f b = (project >>> fmap (runKleisli $ Kleisli pure &&& Kleisli (paraM f)) >>> (>>= f) . sequence) b

l : (Eq a, Monad m)
  => (Text -> Date -> m Decimal)
  -> (C a -> C a -> C a)
  -> F a (C a) -> ResultT m (C a)

l _ _ ZeroF = pure Zero
l _ _ (OneF id) = do
  (t, qty) <- get
  tell [(qty, "TODO: write should be parametrised on asset type")]
  pure Zero -- this is is sort of redundant as When prunes nodes too.
l _ _ (GiveF c) = do
  modify \(t, qty) -> (t, -qty)
  pure $ Give c
l spot _ (WhenF obs c) = do
  (t, qty) <- get
  predicate <- lift ((runKleisli (eval spot obs)) t)
  if predicate then pure Zero else pure $ When obs c
l spot _ (ScaleF obs c) = do
  (t, qty) <- get
  k <- lift ((runKleisli (eval spot obs)) t)
  put (t, qty * k)
  pure $ Scale obs c
l _ choose (OrF c c') = do
  let choice' = choose c c'
  if | choice' == c -> pure c
     | choice' == c' -> pure c'
     | otherwise -> error "lifecycle: Invalid branch election"
l _ _ (AndF Zero c) = pure c
l _ _ (AndF c Zero) = pure c
l _ _ (AndF c c') = pure $ And c c'
l spot _ (CondF obs c c') = do
  (t, qty) <- get
  predicate <- lift ((runKleisli (eval spot obs)) t)
  if predicate then pure c else pure c'
  

lifecycle' : (Eq a, Monad m)
  => (a -> Decimal -> Date -> m c)
  -> (Text -> Date -> m Decimal)
  -> (C a -> C a -> C a)
  -> F a (C a, Kleisli (Kleisli m Date) Decimal [c])
  -> Kleisli (Kleisli m Date) Decimal [c]
-- ^ Lifecycling Algebra
-- | Uses an continuation to 'bubble up' the scale factor.
-- | TODO: re-write to evalute observations eagerly, and prune stale nodes top-down. Currently this traverses the entire tree (even stale nodes).
lifecycle' runSettl runSpot branch = \case
  ZeroF -> skip
  OneF a -> do
    cid <- runSettl' a
    return [cid]
  GiveF _ -> error "Unimplemented: settle GiveF" -- TODO
  AndF (_, g) (_, g') -> liftA2 (++) g g'
  OrF (c, g) (c', g') -> let b = branch c c' in
    if b == c then g
      else if b == c' then g'
         else error "Lifecycle.settle: Non-existent branch chosen."
  CondF p (_, g) (_, g') -> conditionally p g g'
  ScaleF k (_, g) -> do
    k <- oldlift . eval runSpot $ k
    lmap (k *) g
  WhenF p (_, g) -> conditionally p g skip
--      AnytimeF p g -> conditionally p g skip
--      UntilF p g -> conditionally p g skip --FIXME: this is incorrect

  where
    conditionally p g g' = do
      p <- oldlift . eval runSpot $ p
      if p then g else g'

    skip = pure []

    -- runSettl' : a -> (Kleisli (Kleisli m t) Decimal c)
    runSettl' a =  Kleisli (rmap Kleisli (runSettl a))

oldlift : Kleisli m t x -> Kleisli (Kleisli m t) Decimal x
oldlift = Kleisli . const

-- Prune the node with given asset/quantity/date
-- FIXME: this should only prune a _single_ instance of that node.
pruneLeaf
  : (Eq a, Monad m)
  => (Text -> Date -> m Decimal)
  -> a -> Decimal
  -> C a
  -> Date -> m (C a)
pruneLeaf runSpot asset qty o = runKleisli (runKleisli (para (pruneLeaf' runSpot asset qty) o) 1.0)

pruneLeaf' : (Eq a, Monad m)
  => (Text -> Date -> m Decimal)
  -> a
  -> Decimal
  -> F a (C a, Kleisli (Kleisli m Date) Decimal (C a))
  -> Kleisli (Kleisli m Date) Decimal (C a)
pruneLeaf' runSpot asset qty = \case
  ZeroF -> pure Zero
  OneF a' ->
    Kleisli \qty' ->
      Kleisli \_ ->
        if qty' == qty && asset == a' then pure Zero else pure $ One a'
  GiveF (o, g) -> do
    trimmed <- g
    if trimmed == Zero then pure Zero else pure $ Give o
  ScaleF k (_, g) -> do
    k <- oldlift . eval runSpot $ k
    lmap (k *) g
  WhenF p (o, g) -> do
    b <- oldlift . eval runSpot $ p
    if b then g else pure $ When p o
  AndF (o, g) (o', g') -> do -- TODO: this can be optimized to eval rhs lazily
    trimmed <- g
    trimmed' <- g'
    case (trimmed, trimmed') of
      (Zero, _) -> pure trimmed'
      (_, Zero) -> pure trimmed
      _ -> pure $ And o o'
  OrF (o, _) (o', _) -> pure $ Or o o' -- These should be removes using `pruneOr`
  CondF p (o, g) (o', g') -> do
    b <- oldlift . eval runSpot $ p
    if b then g else g'

-- Prunes *other* branch(es) in an 'Or' node, by structural equality.
-- FIXME: ignores 'Give'
pruneOr
  : Eq a
  => C a
  -> C a
  -> C a
pruneOr = apo . pruneOr'

pruneOr'
  : Eq a
  => C a
  -> C a
  -> F a (Either (C a) (C a))
pruneOr' branchToKeep (Or o o') | o == branchToKeep = Left <$> project branchToKeep
pruneOr' branchToKeep (Or o o') | o' == branchToKeep = Left <$> project branchToKeep
pruneOr' _ other = Right <$> project other

