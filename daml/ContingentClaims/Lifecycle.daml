--
-- Copyright (c) 2021, Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0
--

{-# OPTIONS -Wno-deprecations #-} -- To supress 'Monad' warnings

module ContingentClaims.Lifecycle (
    lifecycle
  , lifecycle'
  , Result(..)
) where

import ContingentClaims.Claim (Claim, Claim(..), ClaimF(..))
import ContingentClaims.Observation (Observation, eval, konst)
import Daml.Control.Arrow (Kleisli(..))
import Prelude hiding (sequence, mapA)

type C a = Claim Observation Date a
type F a = ClaimF Observation Date a

-- | Returned from a lifecycle operation.
data Result a = Result with
  remaining : C a
    -- ^ the tree after lifecycled branches have been pruned.
  pending : [(Decimal, a)]
    -- ^ quantity/asset pairs requiring settlement.
  observed : [Text]
    -- ^ Observed conditionals that we lifecycled.

-- | Lifecycle a Claim. Parameters:
-- 1. Function taking key and date, used to lookup an observable on the ledger. `m` will typically be `Update`. It is parametrised so it can be run in a `Script`.
-- 2. Function used when branching in an `Or`. Must return one of the arguments.
-- 3. A set of `Claim`s.
-- 4. A function which, given a date, lifecycles the third argument.
lifecycle : (Eq a, CanAbort m)
  => (Text -> Date -> m Decimal)
  -- -> (C a -> C a -> C a)
  -> (C a -> C a -> Bool)    -- True -> First, False -> Second
  -> C a
  -> Date
  -> m (Result a)
lifecycle spot choose claim date =
  runKleisli (lifecycle' spot choose claim) date

{-
  = runKleisli
  . fmap (uncurry Result)
  . flip evalStateT 1.0
  . runWriterT
  . apoCataM (pruneZeros') (lifecycle' spot choose)
  -}

--type Seed m a = WriterT [(Decimal, a)] (StateT Decimal (Kleisli m Date)) (F a (Either (C a) (C a)))
--type Seed m a = Kleisli m Date)) (F a (Either (C a) (C a)))

-- While lifecycling if the remaining state is zero, then the Claim combinators
-- can be applied to the pending. Otherwise we need to reconstruct the Claim.
isZero : C a -> Bool
isZero Zero = True
isZero _  = False

scaleBy : Decimal -> (Decimal, a) -> (Decimal, a)
scaleBy k (c, a) = (k * c, a)

reduceZero : C a -> C a
reduceZero (And Zero Zero)    = Zero
reduceZero (And lhs Zero)     = lhs
reduceZero (And Zero rhs)     = rhs
reduceZero (Anytime _ _ Zero) = Zero   -- ?
reduceZero (Until _ _ Zero)   = Zero
reduceZero c                  = c

stop : C a -> Result a
stop r = Result with remaining = r, pending = [], observed = []

observe : Text -> Result a -> Result a
observe l r = r with observed = l :: r.observed

lifecycle' : (Eq a, CanAbort m)
  => (Text -> Date -> m Decimal)
  -> (C a -> C a -> Bool)    -- True -> First, False -> Second
  -> C a
  -> Kleisli m Date (Result a)
lifecycle' _    _       Zero      =
  return $ stop Zero
lifecycle' _    _       (One a)   =
  return Result with remaining = Zero, pending = [(1.0, a)] , observed = []
lifecycle' spot choose  (Give c)  = do
  r <- lifecycle' spot choose c
  -- In true Defi, we cannot recurse down `c` as it may contain `Or`'s
  -- that the counter part might choose differently, then even what is
  -- in the interest of the current bearer. They may even choose NOT
  -- to lifecycle the option.
  if isZero r.remaining then
    return $ r with pending = map (scaleBy (-1.0)) r.pending
  else
    return r with remaining = Give r.remaining
lifecycle' spot choose  (Repeat c)  = do
  r <- lifecycle' spot choose c
  return $ r with remaining = (Repeat c)
lifecycle' spot choose  (When obs c)   = do
  predicate <- eval spot obs
  if predicate then do
    lifecycle' spot choose c
  else
    return $ stop $ When obs c
lifecycle' spot choose  (And lhs rhs) = do
  l <- lifecycle' spot choose lhs
  r <- lifecycle' spot choose rhs
  return Result with
          remaining = reduceZero (And l.remaining r.remaining)
          pending = l.pending <> r.pending
          observed = l.observed <> r.observed
lifecycle' spot choose  (Or lhs rhs) = do
  lifecycle' spot choose (if choose lhs rhs then lhs else rhs)
lifecycle' spot choose  (Cond obs success failure) = do
  predicate <- eval spot obs
  lifecycle' spot choose $ if predicate then success else failure
lifecycle' spot choose  (Scale obs c) = do
  k <- eval spot obs
  r <- lifecycle' spot choose c
  if isZero r.remaining then
    return r with pending = map (scaleBy k) r.pending
  else
    -- If this was not a constant before it is now, as the holder has
    -- acquired the scaled version.
    return r with remaining = (Scale (konst k) r.remaining)
lifecycle' spot choose  (Anytime obs zlabel c) = do
  predicate <- eval spot obs
  r <- lifecycle' spot choose c
  if predicate && choose c (Anytime obs zlabel c) then
    return r
  else
    case r.remaining of
      Zero -> return $ observe zlabel $ r with pending = []
      _ -> return $ stop $ Anytime obs zlabel c
lifecycle' spot choose  (Until obs zlabel c)   = do
  predicate <- eval spot obs
  if predicate then do
    return $ observe zlabel $ stop Zero
  else do
    r <- lifecycle' spot choose c
    return r with remaining = reduceZero (Until obs zlabel r.remaining)
lifecycle' spot choose (Label l o) = do
  r <- lifecycle' spot choose o
  return $ observe l r