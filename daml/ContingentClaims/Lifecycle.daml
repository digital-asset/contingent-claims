-- Copyright (c) 2022 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

{-# OPTIONS -Wno-deprecations #-} -- To supress 'Monad' warnings

module ContingentClaims.Lifecycle (
    lifecycle
  , lifecycle'
  , acquire'
  , exercise
  , exercise'
  , expire
  , Result(..)
  , AcquisitionTime(..)
) where

import ContingentClaims.Claim (Claim, Claim(..), ClaimF(..), compare, Inequality(..))
import ContingentClaims.Observation qualified as Observation
import ContingentClaims.Util.Recursion (apoCataM)
import ContingentClaims.Util (pruneZeros')
import Daml.Control.Recursion (project, embed, distApo)
import Daml.Control.Monad.Trans.Writer (WriterT, runWriterT)
import Daml.Control.Monad.Writer.Class (MonadWriter(..))
import Daml.Control.Monad.Trans.Class (lift)
import DA.Traversable (sequence)
import DA.Foldable (sequence_, elem)
import Prelude hiding (sequence, mapA, exercise, compare, elem)

type C t a = Claim t Decimal a
type F t a = ClaimF t Decimal a

-- | Returned from a `lifecycle` operation.
data Result t a = Result with
  pending : [(Decimal, a)]
    -- ^ quantity/asset pairs requiring settlement.
  remaining : C t a
    -- ^ the tree after lifecycled branches have been pruned.

-- | Acquisition time of a (sub)contract. 
-- It becomes known after we cross the first `When` node. Before that, we consider it is "minus infinity". 
data AcquisitionTime t = MinusInfinity | Time t deriving (Eq, Show)

instance (Ord t) => Ord (AcquisitionTime t) where 
  (Time s) <= (Time t) = s <= t
  MinusInfinity <= _ = True
  _ <= MinusInfinity = False

-- | Collect claims falling due into a list, and return the tree with those nodes pruned.
-- `m` will typically be `Update`. It is parametrised so it can be run in a `Script`.
-- The first argument is used to lookup the value of any `Observables`.
-- Results in a function taking today's date, and returning the pruned tree + pending settlements.
lifecycle : (Ord t, Eq a, CanAbort m)
  => (a -> t -> m Decimal)
  -- ^ function to evaluate observables 
  -> C t a
  -- ^ the input claim
  -> t
  -- ^ the today's date
  -> m (Result t a)
lifecycle spot claim today
  = fmap (uncurry $ flip Result)
  . runWriterT
  . apoCataM pruneZeros' acquireThenSettle
  . ((MinusInfinity, 1.0), ) 
  $ claim
  where
    acquireThenSettle =
      fmap (fmap (fmap join))
      . fmap (fmap distE)
      . fmap join
      . fmap (fmap sequence)
      . fmap (fmap (fmap (lifecycle' spot)))
      . fmap (fmap sequence)
      . fmap sequence
      . fmap
      . fmap (fmap (fmap embed))
      . fmap (fmap (tsidE : F t a (Either (C t a) (C t a)) -> Either (C t a) (F t a (C t a)) ))
      . fmap lift
      $ acquire' spot today
    distE = distApo
     -- This is degenerate if you have e.g. `And Left Right`, but that should never happen in practice.
    tsidE f = case sequence_ f of
      Left _ -> Left (embed (fmap foldE f))
      Right _ -> Right (fmap foldE f)
    foldE (Left x) = x
    foldE (Right x) = x

-- | Evaluate observables and skip branches for which predicates don't hold.
-- Consume `Cond` nodes, leaving the relevant sub-tree.
-- Replace `When cond c` nodes with `When (TimeGte t) c` if the condition is non-deterministic and evaluates to True.
-- This is useless on its own. Composed with other functions, it adds laziness.
acquire' : (Ord t, Eq a, Monad m)
  => (a -> t -> m Decimal)
  -- ^ function to evaluate observables 
  -> t
  -- ^ the today date
  -> C t a
  -- ^ the input claim 
  -> m (F t a (Either (C t a) (C t a)))
acquire' spot t (When obs c) = do
  predicate <- compare spot obs t
  if predicate then
    case obs of
      TimeGte _ -> pure $ WhenF obs (Right c)
      other -> pure $ WhenF (TimeGte t) (Right c)
      -- ^ if the condition `cond` is non-deterministic, we assume that we are lifecycling at a time `t` corresponding to the first instant the condition becomes True
    else
      pure $ Left <$> WhenF obs c
acquire' spot today (Cond obs c c') = do
  predicate <- compare spot obs today
  if predicate then acquire' spot today c else acquire' spot today c'
acquire' spot today (Anytime obs c) = do
  predicate <- compare spot obs today
  pure $ AnytimeF obs if predicate then Right c else Left c
acquire' _ _ other = pure $ Right <$> project other

-- | Evaluate any observables in `Scale` nodes, accumulating scale factors and 
-- propagating the claim's acquisition times top-down.
-- Log the scale factors with their corresponding leaf values. 
-- Skip `Or` and `Anytime` branches, guaranteeing liveness. 
-- Replace any Ones that can be reached with Zeros.
lifecycle' : (Ord t, CanAbort m)
        => (a -> t -> m Decimal)
        -> ((AcquisitionTime t, Decimal), C t a) -> WriterT [(Decimal, a)] m (F t a (Either (C t a) ((AcquisitionTime t, Decimal), C t a)))
lifecycle' _ ((_, qty), One asset) = do
  tell [(qty, asset)]
  pure $ Right <$> ZeroF
lifecycle' _ ((s, qty), Give c) =
  pure . GiveF $ Right ((s, -qty), c)
lifecycle' spot ((s, qty), Scale obs c) = do
  k <- lift $ case s of 
    (Time s) -> Observation.eval spot obs s
    MinusInfinity -> abort "Found Scale node with undefined acquisition time"
  pure . ScaleF obs $ Right ((s, k * qty), c)
lifecycle' _ (_, c@Or{}) = pure $ Left <$> project c
lifecycle' _ (_, c@(Anytime _ _)) = pure $ Left <$> project c
lifecycle' _ ((s, qty), When cond c) = do
  acquisitionTime <- case cond of
    TimeGte tau -> pure $ max (Time tau) s
    -- ^ (TimeGte tau) becomes True exactly at time t = tau
    other -> abort "Not expecting to find non-deterministic predicate at this stage"
    -- ^ we should never land on this case, as acquire' "fixes" the acquisition date for non-deterministic predicates
  lift $ pure $ WhenF cond $ Right ((acquisitionTime, qty), c)
lifecycle' _ ((s, qty), other) = pure $ Right . ((s, qty), ) <$> project other


--  | Acquire `Anytime` and `Or` nodes, by making an election.
-- `import` this `qualified`, to avoid clashes with `Prelude.exercise`.
exercise : (Ord t, Eq a, Monad m) => (a -> t -> m Decimal) -> (Bool, C t a) -> C t a -> t -> m (C t a)
exercise spot election claim today = apoCataM pruneZeros' acquireThenExercise . (True, ) $ claim where
  acquireThenExercise = fmap (fmap (fmap join))
                        . fmap (fmap distE)
                        . fmap (fmap (fmap (exercise' election today)))
                        . fmap (fmap sequence)
                        . fmap sequence . fmap
                        . fmap (fmap (fmap embed))
                        . fmap (fmap tsidE)
                        $ acquire' spot today
  distE = distApo
  tsidE f = case sequence_ f of
    Left _ -> Left (embed (fmap foldE f))
    Right _ -> Right (fmap foldE f)
  foldE (Left x) = x
  foldE (Right x) = x

-- | Coalgebra for `exercise`.
-- Resolves `Or` nodes by removing them (keeping elected subtrees).
-- Fixes acquisition time of exercised `Anytime` nodes by replacing them with `When (TimeGte t)`.
-- The election consists of a boolean representing the authorizer (`True = bearer`),
-- and this is compared against available branches of the choice.
exercise' : (Eq t, Eq a)
  => (Bool, C t a)
  -- ^ the election being made
  -> t
  -- ^ the election date
  -> (Bool, C t a)
  -- ^ the input claim and a flag keeping track of who is the entitled to the election (`True = bearer`)
  -> (F t a (Either (C t a) (Bool, C t a)))
exercise' _ _ (isBearer, Give c) = GiveF . Right $ (not isBearer, c)
exercise' (elector, election) _ (isBearer, ors@Or {})
  | elector /= isBearer = Left <$> project ors
  | election `elem` project ors = Right . (isBearer,) <$> project election
  | otherwise = Left <$> project ors
exercise' (elector, election) t (isBearer, f@(Anytime _ c)) =
  if elector == isBearer && election == c then Right . (isBearer, ) <$> WhenF (TimeGte t) c
                                          else Left <$> project f
exercise' _ _ (isBearer, other) = Right . (isBearer, ) <$> project other

-- | Replace any subtrees that have expired with `Zero`s.
expire : (Ord t, Eq a, Monad m) => (a -> t -> m Decimal) -> C t a -> t -> m (C t a)
expire spot claim today = apoCataM pruneZeros' acquireThenExpire claim where
  acquireThenExpire = fmap (fmap distE)
                      . fmap join
                      . fmap (fmap sequence)
                      . fmap (fmap (fmap (expire' spot today)))
                      . fmap (fmap (fmap embed))
                      . fmap (fmap tsidE)
                      $ acquire' spot today
  distE = distApo
  tsidE f = case sequence_ f of
    Left _ -> Left (embed (fmap foldE f))
    Right _ -> Right (fmap foldE f)
  foldE (Left x) = x
  foldE (Right x) = x

-- | Coalgebra for `expire`.
expire' : (Ord t, Monad m) => (a -> t -> m Decimal) -> t -> C t a -> m (F t a (C t a))
expire' spot t (Until obs c) = do
  predicate <- compare spot obs t
  if predicate then pure ZeroF else pure $ UntilF obs c
expire' _ _ other = pure . project $ other
