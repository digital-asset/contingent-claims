-- Copyright (c) 2022 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

{-# OPTIONS -Wno-deprecations #-} -- To supress 'Monad' warnings

module ContingentClaims.Lifecycle (
    lifecycle
  , lifecycle'
  , acquire'
  , exercise
  , exercise'
  , expire
  , Result(..)
) where

import ContingentClaims.Claim (Claim, Claim(..), ClaimF(..), compare)
import ContingentClaims.Observation qualified as Observation
import ContingentClaims.Util.Recursion (apoCataM)
import ContingentClaims.Util (pruneZeros')
import Daml.Control.Recursion (project, embed, distApo)
import Daml.Control.Monad.Trans.Writer (WriterT, runWriterT)
import Daml.Control.Monad.Writer.Class (MonadWriter(..))
import Daml.Control.Monad.Trans.Class
import Daml.Control.Arrow (Kleisli(..))
import DA.Traversable (sequence)
import DA.Foldable (sequence_, elem)
import Prelude hiding (sequence, mapA, exercise, compare, elem)

type C t a = Claim t Decimal a
type F t a = ClaimF t Decimal a

-- | Returned from a `lifecycle` operation.
data Result t a = Result with
  pending : [(Decimal, a)]
    -- ^ quantity/asset pairs requiring settlement.
  remaining : C t a
    -- ^ the tree after lifecycled branches have been pruned.
    deriving (Eq, Show)

-- | Collect claims falling due into a list, and return the tree with those nodes pruned.
-- `m` will typically be `Update`. It is parametrised so it can be run in a `Script`.
-- The first argument is used to lookup the value of any `Observables`.
-- Results in a function taking today's date, and returning the pruned tree + pending settlements.
lifecycle : (Ord t, Eq a, CanAbort m)
  => (a -> t -> m Decimal)
  -> C t a
  -> t -> m (Result t a)
lifecycle spot
  = runKleisli
  . fmap (uncurry $ flip Result)
  . runWriterT
  . apoCataM pruneZeros' acquireThenSettle
  . (1.0, )
  where
    acquireThenSettle =
      fmap (fmap (fmap join))
      . fmap (fmap distE)
      . fmap join
      . fmap (fmap sequence)
      . fmap (fmap (fmap (lifecycle' spot)))
      . fmap (fmap sequence)
      . fmap sequence
      . fmap
      . fmap (fmap (fmap embed))
      . fmap (fmap (tsidE : F t a (Either (C t a) (C t a)) -> Either (C t a) (F t a (C t a)) ))
      . fmap lift
      $ acquire' spot
    distE = distApo
     -- This is degenerate if you have e.g. `And Left Right`, but that should never happen in practice.
    tsidE f = case sequence_ f of
      Left _ -> Left (embed (fmap foldE f))
      Right _ -> Right (fmap foldE f)
    foldE (Left x) = x
    foldE (Right x) = x

-- | Evaluate observables and skip branches for which predicates don't hold.
-- Consumes `When` and `Cond` when appropriate, leaving their subtrees.
-- This is useless on its own. Composed with other functions, it adds laziness.
acquire' : (Ord t, Eq a, Monad m)
  => (a -> t -> m Decimal)
  -> C t a -> Kleisli m t (F t a (Either (C t a) (C t a)))
acquire' spot (When obs c) = do
  predicate <- compare spot obs
  if predicate then acquire' spot c else pure $ WhenF obs (Left c)
acquire' spot (Cond obs c c') = do
  predicate <- compare spot obs
  if predicate then acquire' spot c else acquire' spot c'
acquire' spot (Anytime obs c) = do
  predicate <- compare spot obs
  pure $ AnytimeF obs if predicate then Right c else Left c
acquire' _ other = pure $ Right <$> project other

-- | Evaluate any observables in `Scale` nodes, accumulating scale factors
-- top-down, and log these with their corresponding leaf values. Skip `Or` and
-- `Anytime` branches, guaranteeing liveness.
lifecycle' : CanAbort m
        => (a -> t -> m Decimal)
        -> (Decimal, C t a) -> WriterT [(Decimal, a)] (Kleisli m t) (F t a (Either (C t a) (Decimal, C t a)))
lifecycle' _ (qty, One asset) = do
  tell [(qty, asset)]
  pure $ Right <$> ZeroF
lifecycle' _ (qty, Give c) =
  pure . GiveF $ Right (-qty, c)
lifecycle' spot (qty, Scale obs c) = do
  k <- lift $ Observation.eval spot obs
  pure . ScaleF obs $ Right (k * qty, c)
lifecycle' _ (_, c@Or{}) = pure $ Left <$> project c
lifecycle' _ (_, c@(Anytime _ _)) = pure $ Left <$> project c
lifecycle' _ (qty, other) = pure $ Right . (qty, ) <$> project other

--  | Acquire `Anytime` and `Or` nodes, by making an election.
-- `import` this `qualified`, to avoid clashes with `Prelude.exercise`.
exercise : (Ord t, Eq a, Monad m) => (a -> t -> m Decimal) -> (Bool, C t a) -> C t a -> t -> m (C t a)
exercise spot election = runKleisli . apoCataM pruneZeros' acquireThenExercise . (True, ) where
  acquireThenExercise = fmap (fmap (fmap join))
                        . fmap (fmap distE)
                        . fmap (fmap (fmap (exercise' election)))
                        . fmap (fmap sequence)
                        . fmap sequence . fmap
                        . fmap (fmap (fmap embed))
                        . fmap (fmap tsidE)
                        $ acquire' spot
  distE = distApo
  tsidE f = case sequence_ f of
    Left _ -> Left (embed (fmap foldE f))
    Right _ -> Right (fmap foldE f)
  foldE (Left x) = x
  foldE (Right x) = x

-- | Coalgebra for `exercise`.
-- Resolves `Or` and `Anytime` nodes by removing them (keeping elected subtrees).
-- The election consists of a boolean representing the authorizer (`True = bearer`),
-- and this is compared against available branches of the choice.
exercise' : (Eq t, Eq a) => (Bool, C t a) -> (Bool, C t a) -> (F t a (Either (C t a) (Bool, C t a)))
exercise' _ (isBearer, Give c) = GiveF . Right $ (not isBearer, c)
exercise' (elector, election) (isBearer, ors@Or {}) | elector /= isBearer = Left <$> project ors 
                                                    | election `elem` project ors = Right . (isBearer,) <$> project election 
                                                    | otherwise = Left <$> project ors 
exercise' (elector, election) (isBearer, f@(Anytime _ c)) =
  if elector == isBearer && election == c then Right . (isBearer, ) <$> project c
                                          else Left <$> project f
exercise' _ (isBearer, other) = Right . (isBearer, ) <$> project other

-- | Replace any subtrees that have expired with `Zero`s.
expire : (Ord t, Eq a, Monad m) => (a -> t -> m Decimal) -> C t a -> t -> m (C t a)
expire spot = runKleisli . apoCataM pruneZeros' acquireThenExpire where
  acquireThenExpire = fmap (fmap distE)
                      . fmap join
                      . fmap (fmap sequence)
                      . fmap (fmap (fmap (expire' spot)))
                      . fmap (fmap (fmap embed))
                      . fmap (fmap tsidE)
                      $ acquire' spot
  distE = distApo
  tsidE f = case sequence_ f of
    Left _ -> Left (embed (fmap foldE f))
    Right _ -> Right (fmap foldE f)
  foldE (Left x) = x
  foldE (Right x) = x

-- | Coalgebra for `expire`.
expire' : (Ord t, Monad m) => (a -> t -> m Decimal) -> C t a -> Kleisli m t (F t a (C t a))
expire' spot (Until obs c) = do
  predicate <- compare spot obs
  if predicate then pure ZeroF else pure $ UntilF obs c
expire' _ other = pure . project $ other
