--
-- Copyright (c) 2021, Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0
--

module ContingentClaims.FinancialClaim where

import Prelude hiding (and, or, time)
import ContingentClaims.Claim
import ContingentClaims.Observable qualified as O
import ContingentClaims.Observable (TimeF, PointF, InequalityF, Observable)
import Daml.Control.Recursion
import DA.Date (date, Month)

-- | Helper function to generate a series of fixing dates, e.g. for coupon payments in `fixed`.
-- This assumes `fixingMonths` and `fixingDates` are ordered.
-- The [finance lib](https://github.com/digital-asset/lib-finance) has more feature-complete date handling functions.
unrollDates : Int -> Int -> [Month] -> Int -> [Date]
unrollDates issueYear maturityYear fixingMonths fixingDay =
  date <$> [issueYear .. maturityYear] <*> fixingMonths <*> [fixingDay]

-- | Observable that is true on the passed time. i.e. identity for the time observable.
at
  : forall f t . (TimeF f t, PointF f t t, InequalityF f t t)
  => t -> f t Bool
at t = O.time O.== (O.pure t)

-- | Forward agreement. Discounted by (potentially stochastic) interest rate `r`.
forward : Observable f t => t -> f t Decimal -> Claim f t a -> Claim f t a
forward maturity r payoff = When (at maturity) $ Scale r payoff

-- | Forward rate agreement.
fra : Observable f t => t -> t -> f t Decimal -> f t Decimal -> Claim f t a -> Claim f t a
fra t₁ t₂ r₀ r₁ = forward t₁ r₀ . forward t₂ r₁

-- | Zero Coupon Bond.
zcb : Observable f t => t -> Decimal -> ccy -> Claim f t ccy
zcb maturity principal ccy = forward maturity (O.pure principal) (One ccy)

-- | A floating rate bond. The first two arguments are `Observable`s.
floating : Observable f t => f t Decimal -> f t Decimal -> ccy -> [t] -> Claim f t ccy
floating principal coupon asset = apo \case
     [maturity] -> Left (forward maturity coupon (One asset)) `AndF` 
                   Left (forward maturity principal (One asset))
     (t :: ts) -> Left (forward t coupon (One asset)) `AndF` Right ts
     [] -> ZeroF

-- | A (fixed rate) coupon paying bond.
fixed : Observable f t => Decimal -> Decimal -> ccy -> [t] -> Claim f t ccy
fixed principal coupon = floating (O.pure principal) (O.pure coupon)

-- | European option on the passed claim. e.g. call option on S&P 500:
-- ```
-- european (at $ date 2021 05 14) (Zero `Or` observe "SPX" - pure 4200)
-- ```
european
  : forall f t a . (TimeF f t, PointF f t t, InequalityF f t t)
  => t -> Claim f t a -> Claim f t a
european t u = When (at t) (u `Or` Zero)

-- | Bermudan option on the passed claim.
bermudan
  : forall f t a . (TimeF f t, PointF f t t, InequalityF f t t)
  => Claim f t a -> [t] -> Claim f t a
bermudan u = apo \case
  (t :: ts) -> Left (european t u) `OrF` Right ts
  [] -> ZeroF

-- | Asset swap on specific fixing dates `[t]`. For example:
-- ```
-- fixedUsdVsFloatingEur : [t] -> Serializable.Claim Text
-- fixedUsdVsFloatingEur = fixed 100.0 0.02 "USD" `swap` floating (observe "USDEUR" * pure 100.0) (observe "EUR1M") "EUR"
-- ```
swap : forall f t a . ([t] -> Claim f t a) -> ([t] -> Claim f t a) -> [t] -> Claim f t a
swap receive pay ts = receive ts `And` Give (pay ts)

{-
between
  : forall f t a . (TimeF f t, PointF f t t, InequalityF (f t) t, LogicF (f t))
  => t -> t -> f t Bool
between t t' = liftA2 (&&) (O.time O.>= O.pure t) O.&&  (O.time O.<= O.pure t')

american
  : forall f t a . (Ord t, Category f, Applicative (f t))
  => t -> t -> Claim f t a -> Claim f t a
american t t' u = anytime (between t t') u

-}
