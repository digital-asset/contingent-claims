module ContingentClaims.MathML where

import ContingentClaims.Math.Stochastic
import Daml.Control.Recursion

import DA.Map (Map, toList)
import DA.Text (intercalate)
import Prelude hiding (null, elem)

type Attrs = Map Text Text

data Xml = Elem { attributes : Attrs, name : Text, content: [Xml] }
         | Leaf Text

instance Show Xml where
  show Elem{..} = "<" <> name <> as <> ">" <> show content <> "</" <> name <> ">"
    where as = (<>) " " . intercalate ";" . fmap (\(k,v) -> k <> "=" <> v) . toList $ attributes
  show (Leaf t) = t

data XmlF x = ElemF { attributes : Attrs, name : Text, content: [x] }
            | LeafF Text
            deriving (Show, Eq, Functor)

instance Corecursive Xml XmlF where
  embed = undefined

instance Recursive Xml XmlF where
  project = undefined

-- | Renders an `Expr`ession into MathML presentation format
presentation : Expr θ -> [Xml]
presentation = cata \case
  ProcF _f -> [mn "S(θ, t)"]
  AddF x x' -> x ++ [mo "+"] ++ x'
  NegF x -> mo "-" :: x
  MulF x x' -> x ++ [mo "&InvisibleTimes;"] ++ x'
  DivF x x' -> [mfrac x x']
  I_F x x' -> x ++ [mo "&le;"] ++ x'
  E_F x t -> [mi "&Eopf;", mo "&ApplyFunction;", mfenced $ x ++ [mo "&bar" `msub` mn (show t)] ]

-- | An element with no attributes
elem = Elem mempty

-- | A leaf node, text content
text t = [Leaf t]

-- | identifier
mi = elem "mi" . text

-- | operator
mo = elem "mo" . text

-- | number
mn = elem "mn" . text

-- | text
mtext = elem "mtext" . text

-- | string literal
ms = elem "ms" . text

-- | expression inside pair of fences (e.g. brackets)
mfenced = elem "mfenced"

-- | subscript
msub base subscript = elem "msub" [base, subscript]

-- | fraction
mfrac numerator denominator = elem "mfrac" (numerator ++ denominator)
