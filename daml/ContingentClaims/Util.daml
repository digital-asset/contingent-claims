--
-- Copyright (c) 2021, Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0
--

{-# OPTIONS -Wno-deprecations #-} -- To supress 'Monad' warnings

module ContingentClaims.Util (
    enumerateFrom
  , enum'
  , fixings
  , fixings'
  , pruneZeros
  , pruneZeros'
) where

import ContingentClaims.Observable qualified as O (Inequality(..))
import ContingentClaims.Claim (Claim, Claim(..), ClaimF(..))
import ContingentClaims.Util.Recursion (synthesize, subTreeSize')
import Daml.Control.Recursion
import DA.Foldable (fold)
import Prelude hiding (sum, sequence, mapA)

-- Given a tree annotated with the number of nodes in each branch, index it, depth first.
enum' : (Int, Cofree (ClaimF f t x a) Int) -> CofreeF (ClaimF f t x a) Int (Int, Cofree (ClaimF f t x a) Int)
enum' (i, Cofree _ ZeroF) = CofreeF i ZeroF
enum' (i, Cofree _ (OneF id)) = CofreeF i (OneF id)
enum' (i, Cofree _ (WhenF p f)) = CofreeF i (WhenF p (succ i, f))
enum' (i, Cofree _ (ScaleF p f)) = CofreeF i (ScaleF p (succ i, f))
enum' (i, Cofree _ (GiveF f)) = CofreeF i (GiveF (succ i, f))
enum' (i, Cofree _ (AndF f@(Cofree depth _) f')) = CofreeF i (AndF (succ i, f) (succ (i + depth), f'))
enum' (i, Cofree _ (OrF f@(Cofree depth _) f')) = CofreeF i (OrF (succ i, f) (succ (i + depth), f'))
enum' (i, Cofree _ (CondF p f@(Cofree depth _) f')) = CofreeF i (CondF p (succ i, f) (succ (i + depth), f'))

-- Enumerate each node in the tree, starting from from 'zero'
enumerateFrom : Int -> Claim f t x a -> Cofree (ClaimF f t x a) Int
enumerateFrom zero = ana enum' . (zero, ) . synthesize subTreeSize'

fixings : Claim f t x a -> [t]
fixings = cata fixings'

--TODO should fail if dates will never be executed
fixings' : ClaimF f t x a [t] -> [t]
fixings' (WhenF (O.TimeGte t) ts) = t :: ts
fixings' claim = fold claim

pruneZeros : Claim f t x a -> Claim f t x a
pruneZeros = cata pruneZeros'

-- | Prunes sub-trees which are `Zero` a.s.
pruneZeros' : ClaimF f t x a (Claim f t x a) -> Claim f t x a
pruneZeros' (ScaleF _ Zero) = Zero
pruneZeros' (GiveF Zero) = Zero
pruneZeros' (AndF Zero c) = c
pruneZeros' (AndF c Zero) = c
pruneZeros' (WhenF _ Zero) = Zero
pruneZeros' (CondF _ Zero Zero) = Zero
pruneZeros' (OrF Zero Zero) = Zero
pruneZeros' (UntilF _ Zero) = Zero
pruneZeros' other = embed other
