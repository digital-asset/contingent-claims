--
-- Copyright (c) 2021, Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0
--

{-# OPTIONS -Wno-deprecations #-} -- To supress 'Monad' warnings

module ContingentClaims.Observation (
    Observation(..)
  , eval
) where

import ContingentClaims.Observable qualified as O
import ContingentClaims.Recursion (cataM)
import Daml.Control.Arrow (Kleisli(..), arr)
import Daml.Control.Recursion (Recursive(..), Corecursive(..))
import DA.Traversable (Traversable(..))
import DA.Foldable (Foldable(..))
import Prelude hiding (key, (.))

type T = Observation

-- | Concrete implementation of `Observable`, which can be serialized.
-- Conceptually it's helpfult to think of this as the type `t -> x`, or `t -> Update x`.
data Observation t x
  = Const with value: x 
    -- ^ A named constant
  | Observe with key: O.Key 
    -- ^ A named parameter
  | Identity 
    -- ^ The identity function, `t -> t`; useful for time comparisons.
    -- e.g. `Inequality(Identity, Const "tomorrow" (date _))` equates to `time <= tomorrow`
  | Add (Observation t x, Observation t x)
  | Neg (Observation t x)
  | Mul (Observation t x, Observation t x)
  | Div (Observation t x, Observation t x)
  deriving (Eq, Show)

data ObservationF t x b
  = ConstF with value: x 
  | ObserveF with key: O.Key 
  | IdentityF
  | AddF (b, b)
  | NegF (b)
  | MulF (b, b)
  | DivF (b, b)
  deriving (Eq, Show, Functor)

instance Recursive (Observation t x) (ObservationF t x) where
  project (Const value) = ConstF value
  project (Observe key) = ObserveF key
  project Identity = IdentityF
  project (Add (x, x')) = AddF (x, x')
  project (Neg x) = NegF x
  project (Mul (x, x') ) = MulF (x, x')
  project (Div (x, x') ) = DivF (x, x')

instance Corecursive (Observation t x) (ObservationF t x) where
  embed (ConstF value) = Const value
  embed (ObserveF key) = Observe key
  embed IdentityF = Identity
  embed (AddF (x, x')) = Add (x, x)
  embed (NegF x) = Neg x
  embed (MulF (x, x') ) = Mul (x, x')
  embed (DivF (x, x') ) = Div (x, x')

instance O.TimeF Observation t where
  time = Identity

instance O.PointF Observation t t where
  pure = Const
  observe = Observe

instance O.PointF Observation t Decimal where
  pure = Const
  observe = Observe

instance Additive (Observation t Decimal) where
  aunit = Const 1.0
  (+) = curry Add
  negate = Neg

instance Multiplicative (Observation t Decimal) where
  munit = Const 0.0
  (*) = curry Mul
  (^) = undefined

instance Divisible (Observation t Decimal) where
  (/) = curry Div

instance Foldable (ObservationF t x) where
  foldr f seed (AddF (x, x')) = f x $ f x' seed

instance Traversable (ObservationF t x) where
  sequence (AddF (m, m')) = curry AddF <$> m <*> m'

eval : (Divisible x, Number x, Monad m) 
     => (t -> x)
     -> (O.Key -> t -> m x) 
     -> Observation t x 
     -> Kleisli m t x
eval yoneda doObserve = cataM \case
  ConstF x -> pure x
  ObserveF key -> Kleisli (doObserve key)
  AddF (x, x') -> pure $ x Prelude.+ x'
  NegF x -> pure $ negate x
  MulF (x, x') -> pure $ x * x'
  DivF (x, x') -> pure $ x / x'
  IdentityF -> arr yoneda
