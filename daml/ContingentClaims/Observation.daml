--
-- Copyright (c) 2021, Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0
--

{-# OPTIONS -Wno-deprecations #-} -- To supress 'Monad' warnings

module ContingentClaims.Observation (
    Observation(..)
) where

import ContingentClaims.Observable qualified as O
import ContingentClaims.Recursion (cataM)
import Daml.Control.Arrow (Kleisli(..), arr)
import Daml.Control.Recursion (Recursive(..), Corecursive(..))
import DA.Traversable (Traversable(..))
import DA.Foldable (Foldable(..))
import Prelude hiding (key, (.))

type T = Observation

-- | Concrete implementation of `Observable`, which can be serialized.
-- Conceptually it's helpful to think of this as the type `t -> x`, or `t -> Update x`.
data Observation t x
  = Const with value: x 
    -- ^ A named constant
  | Observe with key: O.Key 
    -- ^ A named parameter
  | Add (Observation t x, Observation t x)
  | Neg (Observation t x)
  | Mul (Observation t x, Observation t x)
  | Div (Observation t x, Observation t x)
  deriving (Eq, Show)

data ObservationF t x b
  = ConstF with value: x 
  | ObserveF with key: O.Key 
  | AddF (b, b)
  | NegF (b)
  | MulF (b, b)
  | DivF (b, b)
  deriving (Eq, Show, Functor)

instance Recursive (Observation t x) (ObservationF t x) where
  project (Const value) = ConstF value
  project (Observe key) = ObserveF key
  project (Add (x, x')) = AddF (x, x')
  project (Neg x) = NegF x
  project (Mul (x, x') ) = MulF (x, x')
  project (Div (x, x') ) = DivF (x, x')

instance Corecursive (Observation t x) (ObservationF t x) where
  embed (ConstF value) = Const value
  embed (ObserveF key) = Observe key
  embed (AddF (x, x')) = Add (x, x)
  embed (NegF x) = Neg x
  embed (MulF (x, x') ) = Mul (x, x')
  embed (DivF (x, x') ) = Div (x, x')

instance O.Point Observation t t where
  pure = Const
  observe = Observe

instance O.Point Observation t Decimal where
  pure = Const
  observe = Observe

instance Additive (Observation t Decimal) where
  aunit = Const 1.0
  (+) = curry Add
  negate = Neg

instance Multiplicative (Observation t Decimal) where
  munit = Const 0.0
  (*) = curry Mul
  (^) = undefined

instance Number (Observation t Decimal) where

instance Divisible (Observation t Decimal) where
  (/) = curry Div

instance Foldable (ObservationF t x) where
  foldr f seed (AddF (x, x')) = f x $ f x' seed

instance Traversable (ObservationF t x) where
  sequence (AddF (m, m')) = curry AddF <$> m <*> m'

instance O.Interpret Observation where
  eval doObserve = cataM \case
    ConstF x -> pure x
    ObserveF key -> Kleisli (doObserve key)
    AddF (x, x') -> pure $ x Prelude.+ x'
    NegF x -> pure $ negate x
    MulF (x, x') -> pure $ x * x'
    DivF (x, x') -> pure $ x / x'
  compare doObserve (O.Lte (f, f')) = liftA2 (<=) (O.eval doObserve f) (O.eval doObserve f')
  compare _ (O.TimeLte t) = arr (<= t)
