--
-- Copyright (c) 2021, Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0
--

module ContingentClaims.Financial where

import Prelude hiding (and, or, (<=))
import ContingentClaims.Claim
import ContingentClaims.Observation qualified as O
import ContingentClaims.Observation (Observation)
import DA.Date (date, Month)
import DA.Foldable (foldMap)
import DA.List.Total (last)

-- | Helper function to generate a series of fixing dates, e.g. for coupon payments in `fixed`.
-- This assumes `fixingMonths` and `fixingDates` are ordered.
-- The [finance lib](https://github.com/digital-asset/lib-finance) has more feature-complete date handling functions.
unrollDates : Int -> Int -> [Month] -> Int -> [Date]
unrollDates issueYear maturityYear fixingMonths fixingDay =
  date <$> [issueYear .. maturityYear] <*> fixingMonths <*> [fixingDay]

-- | Forward agreement. Discounted by (potentially stochastic) interest rate `r`.
forward : t -> Observation t x a -> Claim t x a -> Claim t x a
forward maturity r payoff = When (at maturity) $ Scale r payoff

-- | Forward rate agreement.
fra : t -> t -> Observation t x a -> Observation t x a -> Claim t x a -> Claim t x a
fra t₁ t₂ r₀ r₁ = forward t₁ r₀ . forward t₂ r₁

-- | Zero Coupon Bond.
zcb : t -> x -> ccy -> Claim t x ccy
zcb maturity principal ccy = forward maturity (O.pure principal) (One ccy)

-- | A floating rate bond.
floating : forall t x ccy . Observation t x ccy -> Observation t x ccy -> ccy -> [t] -> Claim t x ccy
floating principal coupon asset fixings = (mconcat (mkCoupon <$> fixings)) <> mkPrincipal (last fixings : Optional t) -- TODO: not very efficient, but easy to understand
  where mkCoupon t = forward t coupon (One asset)
        mkPrincipal = foldMap \t -> forward t principal (One asset)

-- | A (fixed rate) coupon paying bond.
fixed : x -> x -> ccy -> [t] -> Claim t x ccy
fixed principal coupon = floating (O.pure principal) (O.pure coupon)

-- | European option on the passed claim. e.g. call option on S&P 500:
-- ```
-- european (date 2021 05 14) (observe "SPX" - pure 4200)
-- ```
european : t -> Claim t x a -> Claim t x a
european maturity payoff = When (at maturity) (payoff `or` zero)

-- | Bermudan option on the passed claim. Given a pre-defined set of times
-- {t_1, t_2, .., t_N}, it allows the holder to acquire the underlying claim on at
-- most one of these times.
bermudan : [t] -> Claim t x a -> Claim t x a
bermudan [] _ = zero
bermudan [t] c = european t c
bermudan (t :: ts) c = when (at t) (c `or` bermudan ts c)

-- | American option (knock-in). The lead parameter is the first possible acquisition date.
-- [ML] This is not correct from a valuation perspective, if we want to use an until block then
-- it should be Until ( t > maturity). The best approximation at the moment for the case of Dates
-- is to use ( t >= maturity + 1 day)
american : Date -> Date -> Claim Date x a -> Claim Date x a
american start maturity payoff = Anytime ((>=) start) $ Until (at $ succ maturity) (payoff `or` zero)
  where (>=) = at

-- | Asset swap on specific fixing dates `[t]`. For example:
-- ```
-- fixedUsdVsFloatingEur : [t] -> Serializable.Claim Text
-- fixedUsdVsFloatingEur = fixed 100.0 0.02 "USD" `swap` floating (observe "USDEUR" * pure 100.0) (observe "EUR1M") "EUR"
-- ```
swap : ([t] -> Claim t x a) -> ([t] -> Claim t x a) -> [t] -> Claim t x a
swap receive pay ts = receive ts <> Give (pay ts)
