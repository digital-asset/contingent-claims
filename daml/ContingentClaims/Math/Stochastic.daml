-- Mathematical expression, derived from `Claim`, used for pricing

module ContingentClaims.Math.Stochastic where

import ContingentClaims.Claim
import ContingentClaims.Observable (Inequality(..))
import ContingentClaims.Observation qualified as O
import Daml.Control.Recursion
import Daml.Control.Arrow ((|||))
import Prelude hiding (Time)

type Time = Decimal
data Process = ConstOne | Riskless | GBM | Vasicek --TODO: Wiener { dt : Expr, dW : Expr } | Levy { }

data ExprF x
  = ConstF Decimal
  | ProcF { name : Text, process: Process , filtration: Time }
  | SupF { f : Time -> x, lowerBound: Time }
  | AddF { lhs: x, rhs: x }
  | NegF x
  | MulF { lhs: x, rhs: x }
  | DivF { lhs: x, rhs: x }
  | I_F { lhs : x, rhs: x }
  | E_F { rv : x, filtration: Time }
  deriving (Functor)

data Expr
  = Const Decimal
  | Proc { name : Text, process : Process , filtration: Time }
  | Sup { f : Time -> Expr, lowerBound: Time }
  | Add (Expr, Expr)
  | Neg (Expr)
  | Mul (Expr, Expr)
  | Div (Expr, Expr)
  | I (Expr , Expr)
  | E { rv : Expr, filtration: Time }

instance Recursive (Expr) (ExprF) where
  project (Const x) = ConstF x
  project Proc{..} = ProcF with ..
  project Sup{..} = SupF with ..
  project (Add (x, x')) = AddF x x'
  project (Neg x) = NegF x
  project (Mul (x,x')) = MulF x x'
  project (Div (x, x')) = DivF x x'
  project (I (x, x')) = I_F x x'
  project E{..} = E_F with ..

instance Corecursive (Expr) (ExprF) where
  embed (ConstF x) = Const x
  embed ProcF{..} = Proc with ..
  embed SupF{..} = Sup with ..
  embed (AddF x x') = Add (x, x')
  embed (NegF x) = Neg x
  embed (MulF x x') = Mul (x, x')
  embed (DivF x x') = Div (x, x')
  embed (I_F x x') = I (x, x')
  embed E_F{..} = E with ..

-- | Converts a `Claim` into the Fundamental Asset Pricing Formula. The ϵ
-- expressions are defined as E1-E10 in the Eber/Peyton-Jones paper. If you
-- squint you can almost see they correspond one-to-one to the formulae in our
-- whitepaper.
fapf : (Eq a, Show a)
     => a
     -> (a -> Process)
     -> (a -> a -> Process)
     -> Claim O.Observation Time Decimal a -> Expr
fapf ccy disc exch = futu coalg . Left . (, 0.0) where
  -- coalg : (Either (Claim, t) Observable) -> Free ExprF (Either (Claim, t) Observable)
  coalg = ϵ ||| υ
  -- ϵ : (Claim, t) -> Free ExprF (Either (Claim, t) Observable)
  ϵ (Zero, _) = ConstF zero
  ϵ (One asset, t) = exch' asset ccy -- assert ident
  ϵ (Give c, t) = NegF . claim $ (c, t)
  ϵ (Scale k c, t) = obs k `MulF` claim (c, t)
  ϵ (And c c', t) = claim (c, t) `AddF` claim (c', t)
  ϵ (Or c c', t) = AddF
      (ind (claim (c , t)) (claim (c', t)) * claim (c , t))
      (ind (claim (c', t)) (claim (c , t)) * claim (c', t)) -- How to distinguish E6/E7?
  ϵ (Cond (TimeGte t') c c', t) = AddF
      (ind (claim (c , t)) (claim (c', t)) * claim (c', t))
      (ind (claim (c', t)) (claim (c , t)) * claim (c , t)) -- How to distinguish E6/E7?
  ϵ (When (TimeGte t') c, t) = MulF
      (disc' ccy t)
      $ ex (claim (c, t') / disc' ccy t') t
  ϵ (Anytime (TimeGte t') c, t) = error "fapf: Anytime"
  ϵ (Until (TimeGte t') c, t) = error "fapf: Until"
  ϵ _ = error "fapf: Stochastic 'Indicator = Lte' functions not supported yet"
  -- υ : Observable -> ExprF Observable
  υ (O.Const {value=k}) = ConstF k
  υ (O.Observe {key=asset}) = exch' asset ccy
  υ (O.Add (x, x')) = AddF (obs x) (obs x')
  υ (O.Neg x) = NegF (obs x)
  υ (O.Mul (x, x')) = MulF (obs x) (obs x')
  υ (O.Div (x, x')) = DivF (obs x) (obs x')

  -- these operators are sugar for writing the futumorphism using `Free`, above
  x * y = Impure $ MulF x y
  x / y = Impure $ DivF x y
  ind x y = Impure $ I_F x y
  ex x t = Impure $ E_F x t
  claim = Pure . Left
  obs = Pure . Right
  disc' k t = Impure $ ProcF (show k) (disc k) t
  exch' asset ccy = if asset == ccy then ConstF one else ProcF (show asset) (exch asset ccy) 0.0  -- FIXME: does it matter this is set to zero?
  one = munit
  zero = aunit

simplify : Expr -> Expr
simplify = cata unitIdentity . cata zeroIdentity . cata factNeg . cata distAdd 

zeroIdentity : ExprF Expr -> Expr
zeroIdentity (MulF (Const 0.0) x) = Const 0.0
zeroIdentity (MulF x (Const 0.0)) = Const 0.0
zeroIdentity (DivF (Const 0.0) x) = Const 0.0
zeroIdentity (AddF (Const 0.0) x) = x
zeroIdentity (AddF x (Const 0.0)) = x
zeroIdentity (E_F (Const 0.0) _) = Const 0.0
zeroIdentity other = embed other

unitIdentity : ExprF Expr -> Expr
unitIdentity (MulF (Const 1.0) x) = x
unitIdentity (MulF x (Const 1.0)) = x
unitIdentity other = embed other

factNeg : ExprF Expr -> Expr
factNeg (NegF (Neg x)) = x
factNeg (MulF (Neg x) y) = Neg $ Mul (x, y)
factNeg (MulF y (Neg x)) = Neg $ Mul (y, x)
factNeg (E_F (Neg x) t) = Neg $ E x t
factNeg other = embed other

distAdd : ExprF Expr -> Expr
distAdd (MulF (Add (x, x')) y) = Add (Mul (x, y), Mul (x', y))
distAdd (MulF y (Add (x, x'))) = Add (Mul (y, x), Mul (y, x'))
distAdd (DivF (Add (x, x')) y) = Add (Div (x, y), Div (x', y))
distAdd (E_F (Add (x, x')) t) = Add (E x t, E x' t)
distAdd other = embed other

{-
distAdd : Expr-> ExprF (Free ExprF Expr)
distAdd (Mul (Add (x, x'), y)) = Impure (Pure x `MulF` Pure y) `AddF` Impure (Pure x' `MulF` Pure y)
distAdd (Mul (y, Add (x, x'))) = Impure (Pure y `MulF` Pure x) `AddF` Impure (Pure y `MulF` Pure x')
distAdd (Div (Add (x, x'), y)) = Impure (Pure x `DivF` Pure y) `AddF` Impure (Pure x' `DivF` Pure y)
distAdd (E (Add (x, x')) t) = Impure (E_F (Pure x) t) `AddF` Impure (E_F (Pure x') t)
distAdd other = Pure <$> project other
-}
