-- Mathematical expression, derived from `Claim`, used for pricing

module ContingentClaims.Math.Stochastic where

import ContingentClaims.Claim
import ContingentClaims.Observable (Inequality(..))
import ContingentClaims.Observation qualified as O
import Daml.Control.Recursion
import Daml.Control.Arrow ((|||))
import Prelude hiding (Time)

type Time = Decimal
type Variable θ = θ -> Decimal
type Process θ = Time -> Variable θ

instance Show (Process θ) where
  show _ = "S(t, θ)"

data ExprF θ x
  = ProcF (Process θ)
  | SupF { f : Time -> x, lowerBound: Time }
  | AddF { lhs: x, rhs: x }
  | NegF x
  | MulF { lhs: x, rhs: x }
  | DivF { lhs: x, rhs: x }
  | I_F { lhs : x, rhs: x }
  | E_F { rv : x, filtration: Time }
  deriving (Functor)

data Expr θ
  = Proc (Process θ)
  | Sup { f : Time -> Expr θ, lowerBound: Time }
  | Add (Expr θ, Expr θ)
  | Neg (Expr θ)
  | Mul (Expr θ, Expr θ)
  | Div (Expr θ, Expr θ)
  | I (Expr θ , Expr θ)
  | E { rv : Expr θ, filtration: Time }

instance Corecursive (Expr θ) (ExprF θ) where
  embed = undefined

-- Fundamental asset pricing formula. The ϵ expressions are defined as E1-E10 in the Eber/Peyton-Jones paper.
fapf : Eq a
     => a
     -> (a -> Time -> Process θ)
     -> (a -> a -> Process θ)
     -> θ
     -> Claim O.Observation Time Decimal a -> Expr θ
fapf ccy disc exch theta = futu coalg . Left where
  -- coalg : (Either Claim Observable) -> Free ExprF (Either Claim Observable)
  coalg = ϵ ||| υ
  -- ϵ : Claim -> Free ExprF (Either Claim Observable)
  ϵ Zero = ProcF . const . const $ zero
  ϵ (One asset) = ProcF $ exch asset ccy
  ϵ (Give c) = NegF . claim $ c
  ϵ (Scale k c) = obs k `MulF` claim c
  ϵ (And c c') = claim c `AddF` claim c'
  ϵ (Or c c') = (ind (claim c) (claim c') * claim c) `AddF` (ind (claim c') (claim c) * claim c') -- How to differentiate these two?
  ϵ (Cond (TimeGte t) c c') = (ind (claim c) (claim c') * claim c') `AddF` (ind (claim c') (claim c) * claim c') -- where does t go?
  ϵ (When (TimeGte t') c) = (disc' ccy undefined) `MulF` exp (disc' ccy t' * claim c) undefined
  ϵ (Anytime (TimeGte t) c) = error "fapf: Anytime"
  ϵ (Until (TimeGte t) c) = error "fapf: Until"
  ϵ _ = error "fapf: Stochastic 'Indicator = Lte' functions not supported yet"
  -- these four operators are sugar for writing the futumorphism using `Free`, above
  x * y = Impure $ MulF x y
  ind x y = Impure $ I_F x y
  exp x t = Impure $ E_F x t
  claim = Pure . Left
  obs = Pure . Right
  disc' x y = Impure . ProcF $ disc x y
  -- υ : Observable -> ExprF Observable
  υ (O.Const {value=k}) = ProcF . const . const $ zero
  υ (O.Observe {key=asset}) = ProcF $ exch (error "TODO asset = key") ccy
  υ (O.Add (x, x')) = AddF (obs x) (obs x')
  υ (O.Neg x) = MulF (Impure . ProcF . const . const . negate $ one) (obs x)
  υ (O.Mul (x, x')) = MulF (obs x) (obs x')
  υ (O.Div (x, x')) = DivF (obs x) (obs x')
  zero = aunit
  one = munit

-- test = script do
