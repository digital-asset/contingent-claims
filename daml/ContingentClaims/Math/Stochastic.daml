-- Mathematical expression, derived from `Claim`, used for pricing

module ContingentClaims.Math.Stochastic where

import ContingentClaims.Claim
import ContingentClaims.Observable (Inequality(..))
import ContingentClaims.Observation qualified as O
import Daml.Control.Recursion hiding (Free(..))
import Daml.Control.Arrow ((|||))
import Daml.Control.Monad.State (State, runState)
import Daml.Control.Monad.MonadState
import Daml.Control.Monad.Free (FreeT(..), FreeF(..))
import Prelude hiding (Time, sequence, mapA, const)

data Process t = Process { dt : Expr t, dW: Expr t } deriving (Show, Eq)-- Geometric i.e. dX / X = α dt + β dW, so we have closed solns.
-- TODO: make sum type and support Poisson

riskless r = Process { dt = Ident r, dW = Const 0.0 }

gbm μ σ = Process { dt = Ident μ, dW = Ident σ }

data ExprF t x
  = ConstF Decimal
  | IdentF Text
  | ProcF { name : Text, process: Process t, filtration: t }
  | SupF { lowerBound: t, tauIdx: x, rv : x } -- tauIdx is the subscript to τ
  | AddF { lhs: x, rhs: x }
  | NegF x
  | MulF { lhs: x, rhs: x }
  | PowF { lhs: x, rhs: x }
  | I_F { lhs : x, rhs: x }
  | E_F { rv : x, filtration: t }
  deriving (Functor)

data Expr t
  = Const Decimal
  | Ident Text
  | Proc { name : Text, process : Process t, filtration: t }
  | Sup { lowerBound: t, tauIdx: Expr t, rv : Expr t }
  | Add (Expr t, Expr t)
  | Neg (Expr t)
  | Mul (Expr t, Expr t)
  | Pow (Expr t, Expr t)
  | I (Expr t , Expr t)
  | E { rv : Expr t, filtration: t }
  deriving (Show, Eq)

instance Recursive (Expr t) (ExprF t) where
  project (Const d) = ConstF d
  project (Ident s) = IdentF s
  project Proc{..} = ProcF with ..
  project Sup{..} = SupF with ..
  project (Add (x, x')) = AddF x x'
  project (Neg x) = NegF x
  project (Mul (x,x')) = MulF x x'
  project (Pow (x, x')) = PowF x x'
  project (I (x, x')) = I_F x x'
  project E{..} = E_F with ..

instance Corecursive (Expr t) (ExprF t) where
  embed (ConstF d) = Const d
  embed (IdentF s) = Ident s
  embed ProcF{..} = Proc with ..
  embed SupF{..} = Sup with ..
  embed (AddF x x') = Add (x, x')
  embed (NegF x) = Neg x
  embed (MulF x x') = Mul (x, x')
  embed (PowF x x') = Pow (x, x')
  embed (I_F x x') = I (x, x')
  embed E_F{..} = E with ..

distFutuT
  : (Functor f, Action m)
  => (forall c. m (f c) -> f (m c))
  -> FreeT f m (f a)
  -> f (FreeT f m a)
distFutuT distM = fmap FreeT . distM . fmap g . runFreeT where
  g (Pure fa) = Pure <$> fa
  g (Free fFreeT) = fmap (Free . distFutuT distM) fFreeT

distCounter : Functor f => State Int (f a) -> f (State Int a)
distCounter st = case runState st 0 of 
  (fa, i) -> fmap (\a -> state \j -> (a, i + j)) fa

-- | Converts a `Claim` into the Fundamental Asset Pricing Formula. The ϵ
-- expressions are defined as E1-E10 in the Eber/Peyton-Jones paper. If you
-- squint you can almost see they correspond one-to-one to the formulae in our
-- whitepaper.
fapf : (Eq a, Show a, Show t)
     => a
     -> (a -> Process t)
     -> (a -> a -> Process t)
     -> t
     -> Claim O.Observation t Decimal a -> Expr t
fapf ccy disc exch today = gana (distFutuT distCounter) coalg . Left . (, today) where
  -- coalg : (Either (Claim, t) (Observable, t)) -> ExprF (FreeT ExprF (State Int) (Either (Claim, t) (Observable, t)))
  coalg = ϵ ||| υ
  -- ϵ : (Claim, t) -> ExprF (FreeT (ExprF t) (State Int) (Either (Claim, t) (Observable, t)))
  ϵ (Zero, _) = ConstF zero
  ϵ (One asset, t) = exch' asset ccy t -- assert ident
  ϵ (Give c, t) = NegF . claim $ (c, t)
  ϵ (Scale k c, t) = obs (k, t) `MulF` claim (c, t)
  ϵ (And c c', t) = claim (c, t) `AddF` claim (c', t)
  ϵ (Or c c', t) = AddF
      (ind (claim (c , t)) (claim (c', t)) * claim (c , t))
      (ind (claim (c', t)) (claim (c , t)) * claim (c', t)) -- How to distinguish E6/E7?
  ϵ (Cond (TimeGte t') c c', t) = AddF
      (ind (claim (c , t)) (claim (c', t)) * claim (c', t))
      (ind (claim (c', t)) (claim (c , t)) * claim (c , t)) -- How to distinguish E6/E7?
  ϵ (When (TimeGte t') c, t) = disc' ccy t `MulF` ex (claim (c, t') / disc' ccy t') t
  ϵ (Anytime (TimeGte t') c, t) = SupF t' τ $ disc' ccy t' * ex (claim (c, t') / disc' ccy t) t
    where τ = do 
              i <- get
              put $ i + 1
              id $ show i
  ϵ (Until (TimeGte t') c, t) = E_F (claim (c, t') * ind (id $ show t) (id $ show t')) t
  ϵ _ = error "fapf: Stochastic 'Indicator = Lte' functions not supported yet"
  -- υ : (Observable, t) -> ExprF (FreeT (ExprF t) (State Int) (Either (Claim, t) (Observable, t)))
  υ (O.Const {value=k}, _) = ConstF k
  υ (O.Observe {key=asset}, t) = exch' asset ccy t
  υ (O.Add (x, x'), t) = obs (x, t) `AddF` obs (x', t)
  υ (O.Neg x, t) = NegF $ obs (x, t)
  υ (O.Mul (x, x'), t) = obs (x, t) `MulF` obs (x', t)
  υ (O.Div (x, x'), t) = obs (x, t) `MulF` inv (obs (x', t))

  -- these operators are sugar for writing the futumorphism using `Free`, above
  x * y = FreeT . pure . Free $ MulF x y
  x / y = FreeT . pure . Free $ MulF x (inv y)
  inv x = FreeT . pure . Free $ PowF x (obs (O.Neg . O.Const $ one, today)) -- t for a `Const` is ignored
  ind x y = FreeT . pure . Free $ I_F x y
  sup t i x = FreeT . pure . Free $ SupF t i x
  ex x t = FreeT . pure . Free $ E_F x t
  id = FreeT . pure . Free . IdentF -- FIXME: this is resulting in quotes wrapped around identifier
  claim = pure . Left
  obs = pure . Right
  disc' k t = FreeT . pure . Free $ ProcF (show k) (disc k) t
  exch' asset ccy t = if asset == ccy then ConstF one else ProcF (show asset) (exch asset ccy) t
  one = munit
  zero = aunit

simplify : Expr t -> Expr t
simplify = 
    cata unitIdentity 
  . cata zeroIdentity 
  . cata factNeg
  . \case [] -> Const aunit
          [x] -> x
          x :: xs -> cata distAdd' xs x
  . cata distAdd
  . ana commuteLeft 
  . cata mulBeforeAdd

zeroIdentity : ExprF t (Expr t) -> Expr t
zeroIdentity (MulF (Const 0.0) x) = Const 0.0
zeroIdentity (MulF x (Const 0.0)) = Const 0.0
zeroIdentity (PowF x (Const 0.0)) = Const 1.0
zeroIdentity (AddF (Const 0.0) x) = x
zeroIdentity (AddF x (Const 0.0)) = x
zeroIdentity (E_F (Const 0.0) _) = Const 0.0
zeroIdentity other = embed other

unitIdentity : ExprF t (Expr t) -> Expr t
unitIdentity (MulF (Const 1.0) x) = x
unitIdentity (MulF x (Const 1.0)) = x
unitIdentity (PowF x (Const 1.0)) = x
unitIdentity other = embed other

factNeg : ExprF t (Expr t) -> Expr t
factNeg (NegF (Neg x)) = x
factNeg (MulF (Neg x) (Neg y)) = Mul (x, y)
factNeg (MulF (Neg x) y) = Neg $ Mul (x, y)
factNeg (MulF y (Neg x)) = Neg $ Mul (y, x)
factNeg (E_F (Neg x) t) = Neg $ E x t
factNeg other = embed other

-- | Turn any expression into a list of terms to be summed together
distAdd : ExprF t [Expr t] -> [Expr t]
distAdd = \case
  ConstF x -> [Const x]
  IdentF x -> [Ident x]
  AddF xs xs' -> xs ++ xs'
  MulF xs xs' -> curry Mul <$> xs <*> xs'
  NegF xs -> Neg <$> xs
  E_F xs t -> flip E t <$> xs
  I_F xs xs' -> [I (unroll xs, unroll xs')]
  PowF xs is -> [Pow (unroll xs, unroll is)]
  ProcF{..} -> [Proc{..}]
  SupF t xs xs' -> [Sup t (unroll xs) (unroll xs')]
  where unroll xs = cata distAdd' xs (Const aunit)

-- | Unroll a list of terms to be summed together into a (left commutative) tree of `Add`s.
distAdd' : ListF (Expr t) (Expr t -> Expr t) -> (Expr t -> Expr t)
distAdd' Nil = identity
distAdd' (Cons r f) = \l -> f . Add $ (l, r)


-- | Change `(a + b) x c` to `c x (a + b)`
mulBeforeAdd : ExprF t (Expr t) -> Expr t
mulBeforeAdd (MulF y@Add{} x) = Mul (x, y)
mulBeforeAdd (MulF (Mul (x, y@Add{})) x') = Mul (Mul (x,x'), y)
mulBeforeAdd other = embed other

-- | Change e.g. `a x (b x c)` to `(a x b) x c`
commuteLeft : Expr t -> ExprF t (Expr t)
commuteLeft (Mul (x,(Mul (a, b)))) = Mul (x, a) `MulF` b
commuteLeft (Add (x,(Add (a, b)))) = Add (x, a) `AddF` b
commuteLeft other = project other
