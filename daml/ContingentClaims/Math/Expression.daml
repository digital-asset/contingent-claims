-- Copyright (c) 2022 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

module ContingentClaims.Math.Expression (
  Expr(..),
  ExprF(..),
) where

import ContingentClaims.Claim (Inequality(..))
import ContingentClaims.Math.AcquisitionTime(AcquisitionTime(..))
import DA.Foldable
import DA.Traversable
import Daml.Control.Recursion
import Prelude hiding (Time, sequence, mapA, const)

-- | Represents an algebraic expression of a t-adapted stochastic process.
-- t : time parameter
-- x : state parameter, typically Decimal (our best approximation of real numbers)
-- o : reference used to identify observables
-- b : type describing elementary processes
data Expr t x o b
  = Const x
      -- ^ A constant process.
  | Proc { name : b }
      -- ^ An elementary process which we cannot decompose further.
  -- | Sup { lowerBound: t, tau: t, rv : Expr t }
      -- ^ Sup, needs to be reworked using feasible exercise strategies.
  | Sum [Expr t x o b]
      -- ^ Sum process.
  | Neg (Expr t x o b)
      -- ^ Negation process.
  | Mul (Expr t x o b, Expr t x o b)
      -- ^ Multiplication process.
  | Inv (Expr t x o b)
      -- ^ Inverse process.
  | Max [Expr t x o b]
      -- ^ Maximum process.
  | I (Inequality t x o)
      -- ^ Indicator function. I(p) is 1 if p(t) = True, False otherwise, where
      -- `p` is the boolen process corrersponding to the provided inequality.
      -- Specifically, this means
      -- - for `o1 ≤ o2`, `p = υ(o1) ≤ υ(o2)`
      -- - for `TimeGte t`, `p(s) = s ≥ t`
      -- - for `TimeLte t`, `p(s) = s ≤ t`
  | E { process : Expr t x o b, time : AcquisitionTime t x o, filtration : AcquisitionTime t x o }
      -- ^ Conditional expectation of `process(time)` conditioned on the filtration F_`t`.
  deriving (Eq,Show)

-- | Base functor for `Expr`.
data ExprF t x o b c
  = ConstF x
  | ProcF { name : b }
  -- | Sup { lowerBound: t, tau: t, rv : Expr t }
  | SumF [c]
  | NegF c
  | MulF { lhs : c, rhs : c }
  | InvF c
  | MaxF [c]
  | I_F (Inequality t x o)
  | E_F { process : c, time : AcquisitionTime t x o, filtration : AcquisitionTime t x o }
  deriving (Functor)

instance Recursive (Expr t x o b) (ExprF t x o b) where
  project (Const d) = ConstF d
  project Proc{..} = ProcF with ..
  -- project Sup{..} = SupF with ..
  project (Sum xs) = SumF xs
  project (Neg x) = NegF x
  project (Mul (x,x')) = MulF x x'
  project (Inv x) = InvF x
  project (Max xs) = MaxF xs
  project (I x) = I_F x
  project E{..} = E_F with ..

instance Corecursive (Expr t x o b) (ExprF t x o b) where
  embed (ConstF d) = Const d
  embed ProcF{..} = Proc with ..
  -- embed SupF{..} = Sup with ..
  embed (SumF xs) = Sum xs
  embed (NegF x) = Neg x
  embed (MulF x x') = Mul (x, x')
  embed (InvF x) = Inv x
  embed (MaxF xs) = Max xs
  embed (I_F x) = I x
  embed E_F{..} = E with ..

instance Foldable (ExprF t x o b) where
  foldMap f (ConstF _) = mempty
  foldMap f (ProcF _) = mempty
  -- foldMap f (SupF _ _ x) = f x
  foldMap f (SumF xs) = foldMap f xs
  foldMap f (NegF x) = f x
  foldMap f (MulF x x') = f x <> f x'
  foldMap f (InvF x) = f x
  foldMap f (MaxF xs) = foldMap f xs
  foldMap f (I_F _) = mempty
  foldMap f (E_F x _ _) = f x

instance Traversable (ExprF t x o b) where
  sequence (ConstF d) = pure $ ConstF d
  sequence (ProcF x) = pure $ ProcF x
--   sequence (SupF t τ fa) = SupF t τ <$> fa
  sequence (SumF [fa]) = (\a -> SumF [a]) <$> fa
  sequence (SumF (fa :: fas)) = s <$> fa <*> sequence fas
    where s a as = SumF (a :: as)
  sequence (SumF []) = error "Traversable ExprF: sequence empty SumF"
  sequence (NegF fa) = NegF <$> fa
  sequence (MulF fa fa') = MulF <$> fa <*> fa'
  sequence (InvF fa) = InvF <$> fa
  sequence (MaxF (fa :: fas)) = s <$> fa <*> sequence fas
    where s a as = MaxF (a :: as)
  sequence (MaxF []) = error "Traversable ExprF: sequence empty MaxF"
  sequence (I_F p) = pure $ I_F p
  sequence (E_F fa t f) = (\a -> E_F a t f) <$> fa

instance (Additive x) => Additive (Expr t x o b) where
  x + y = Sum [x, y]
  negate = Neg
  aunit = Const aunit

instance (Multiplicative x) => Multiplicative (Expr t x o b) where
  (*) = curry Mul
  munit = Const munit
  x ^ y | y > 0 = x * (x ^ pred y)
  x ^ 0 = munit
  x ^ y = Inv x ^ (-y)

instance (Multiplicative x) => Divisible (Expr t x o b) where
  x / y = curry Mul x $ Inv y
