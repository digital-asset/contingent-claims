-- Copyright (c) 2022 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

module ContingentClaims.Math.Expression (
  Expr(..),
  ExprF(..),
) where

import ContingentClaims.Math.AcquisitionTime(AcquisitionTime(..))
import DA.Foldable
import DA.Traversable
import Daml.Control.Recursion
import Prelude hiding (Time, sequence, mapA, const)

-- | Represents an algebraic expression of a t-adapted stochastic process.
-- t : time parameter
-- x : state parameter, typically Decimal
-- o : reference used to identify observables
-- b : type describing elementary processes
data Expr t x o b
  = Const x
      -- ^ A constant process.
  | Ident t
      -- ^ A process that takes the value of the time parameter.
  | Proc { name : b }
      -- ^ An elementary process which we cannot decompose further.
  -- | Sup { lowerBound: t, tau: t, rv : Expr t }
      -- ^ Sup, needs to be reworked using feasible exercise strategies.
  | Sum [Expr t x o b]
      -- ^ Sum process.
  | Neg (Expr t x o b)
      -- ^ Negation process.
  | Mul (Expr t x o b, Expr t x o b)
      -- ^ Multiplication process.
  | Inv (Expr t x o b)
      -- ^ Inverse process.
      -- TODO think in which cases this is well defined
  -- | I (Expr t x o b , Expr t x o b)
      -- ^ Indicator function, rework using inequalities.
  | E { process : Expr t x o b, time : AcquisitionTime t x o, filtration : AcquisitionTime t x o }
      -- ^ Conditional expectation of `process(time)` conditioned on the filtration F_`t`.
  deriving (Eq,Show)

-- | Base functor for `Expr`.
data ExprF t x o b c
  = ConstF x
  | IdentF t
  | ProcF { name : b }
  -- | Sup { lowerBound: t, tau: t, rv : Expr t }
  | SumF [c]
  | NegF c
  | MulF { lhs : c, rhs : c}
  | InvF c
  -- | I (Expr t x o b , Expr t x o b)
  | E_F { process : c, time : AcquisitionTime t x o, filtration : AcquisitionTime t x o }
  deriving (Functor)

instance Recursive (Expr t x o b) (ExprF t x o b) where
  project (Const d) = ConstF d
  project (Ident s) = IdentF s
  project Proc{..} = ProcF with ..
  -- project Sup{..} = SupF with ..
  project (Sum xs) = SumF xs
  project (Neg x) = NegF x
  project (Mul (x,x')) = MulF x x'
  project (Inv x) = InvF x
  -- project (I (x, x')) = I_F x x'
  project E{..} = E_F with ..

instance Corecursive (Expr t x o b) (ExprF t x o b) where
  embed (ConstF d) = Const d
  embed (IdentF s) = Ident s
  embed ProcF{..} = Proc with ..
  -- embed SupF{..} = Sup with ..
  embed (SumF xs) = Sum xs
  embed (NegF x) = Neg x
  embed (MulF x x') = Mul (x, x')
  embed (InvF x) = Inv x
  -- embed (I_F x x') = I (x, x')
  embed E_F{..} = E with ..

instance Foldable (ExprF t x o b) where
  foldMap f (ConstF _) = mempty
  foldMap f (IdentF _) = mempty
  foldMap f (ProcF _) = mempty
  -- foldMap f (SupF _ _ x) = f x
  foldMap f (SumF xs) = foldMap f xs
  foldMap f (NegF x) = f x
  foldMap f (MulF x x') = f x <> f x'
  foldMap f (InvF x) = f x
  -- foldMap f (I_F x x') = f x <> f x'
  foldMap f (E_F x _ _) = f x

instance Traversable (ExprF t x o b) where
  sequence (ConstF d) = pure $ ConstF d
  sequence (IdentF t) = pure $ IdentF t
  sequence (ProcF x) = pure $ ProcF x
--   sequence (SupF t τ fa) = SupF t τ <$> fa
  sequence (SumF [fa]) = (\a -> SumF [a]) <$> fa
  sequence (SumF (fa :: fas)) = s <$> fa <*> sequence fas
    where s a as = SumF (a :: as)
  sequence (SumF []) = error "Traversable ExprF: sequence empty SumF"
  sequence (NegF fa) = NegF <$> fa
  sequence (MulF fa fa') = MulF <$> fa <*> fa'
  sequence (InvF fa) = InvF <$> fa
--   sequence (I_F fa fa') = I_F <$> fa <*> fa'
  sequence (E_F fa t f) = (\a -> E_F a t f) <$> fa

instance (Additive x) => Additive (Expr t x o b) where
  x + y = Sum [x, y]
  negate = Neg
  aunit = Const aunit

instance (Multiplicative x) => Multiplicative (Expr t x o b) where
  (*) = curry Mul
  munit = Const munit
  x ^ y | y > 0 = x * (x ^ pred y)
  x ^ 0 = munit
  x ^ y = Inv x ^ (-y)

instance (Multiplicative x) => Divisible (Expr t x o b) where
  x / y = curry Mul x $ Inv y

-- [ML] we could define this as x * y ^ -1, but we are using the
-- fact that x * Div (munit,y) == Div (x,y)

-- alternatively, instead of using Div Expr Expr we can just use Inv Expr (1 / Expr)
