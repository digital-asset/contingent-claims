-- Copyright (c) 2022 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

-- Mathematical expression, derived from `Claim`, used for pricing

-- | Can I add some module description?
module ContingentClaims.Math.Stochastic2 (
  fapf,
  ElementaryProcess(..),
) where

import ContingentClaims.Internal.Claim (Claim(..))
import ContingentClaims.Claim hiding ((<=))
import ContingentClaims.Math.AcquisitionTime(AcquisitionTime(..), beforeOrAtToday, extend, resolve)
import ContingentClaims.Math.Expression
import ContingentClaims.Observation qualified as O
import ContingentClaims.Util.Recursion (futuM)
import Daml.Control.Arrow ((|||))
import Daml.Control.Recursion
import Prelude hiding (compare)

-- | Elementary processes as described in the Peyton-Jones paper.
-- Once a model assumption is made, these can be replaced by the specific model (e.g. geometric brownian motion for stock spot prices)
data ElementaryProcess a o
  = Observable o
      -- ^ Process corresponding to an observable.
  | Exch with { asset : a, currency : a }
      -- ^ Value of `asset` expressed in units of `currency`.
  | Disc a
      -- ^ Discount factor expressed in currency `a`.
  deriving (Eq, Show)

-- | Maps a claim to the corresponding value process in currency `ccy`, taking into account known information up to time `t`.
fapf : (Ord t, Eq a, Ord x, Number x, Divisible x, CanAbort m)
  => (o -> t -> m x)
     -- ^ function to evaluate observables
  -> a
     -- ^ currency
  -> t
     -- ^ valuation date
  -> t
     -- ^ acquisition time
  -> Claim t x a o
     -- ^ the input claim
  -> m (Expr t x o (ElementaryProcess a o))
fapf spot ccy t acquisitionTime claim =
  futuM coalg
  $ Left (claim, Time acquisitionTime) -- `Left` is used for claims, `Right` for observables
  where
    -- coalg : (Additive x) => (Carrier t x a) -> (ExprF t x a (ElementaryProcess a) (Free (ExprF t x a (ElementaryProcess a)) (Carrier t x a)))
    coalg = ϵ spot t ccy ||| υ

    -- υ : (O.Observation t x a, AcquisitionTime t x a) -> (ExprF t x a (ElementaryProcess a) (Free (ExprF t x a (ElementaryProcess a)) (Carrier t x a)))
    υ (O.Const {value=k}, _) = pure $ ConstF k
    υ (O.Observe {key=observable}, Time s) | s <= t = ConstF <$> spot observable s
    υ (O.Observe {key=observable}, s) = pure . ProcF $ Observable observable
    υ (O.Add (x, x'), s) = pure $ SumF [obs (x, s), obs (x', s)]
    υ (O.Neg x, s) =  pure . NegF $ obs (x, s)
    υ (O.Mul (x, x'), s) = pure $ obs (x, s) `MulF` obs (x', s)
    υ (O.Div (x, x'), t) = pure $ obs (x, t) `MulF` inv (obs (x', t))

    obs = pure . Right
    inv = Free . InvF

ϵ : (Eq a, Ord t, Ord x, Number x, Divisible x, CanAbort m) => (o -> t -> m x) -> t -> a -> (Claim t x a o, AcquisitionTime t x o) -> m (ExprF t x o (ElementaryProcess a o) (Free (ExprF t x o (ElementaryProcess a o)) (Carrier t x a o)))

ϵ _ _ _ (Zero, _) = pure $ ConstF aunit

ϵ _ _ ccy (One asset, _) = pure $ exch asset ccy
  where
    exch asset ccy = if asset == ccy then ConstF munit else ProcF $ Exch asset ccy

ϵ _ _ _ (Give c, s) = pure . NegF $ Pure $ Left (c,s)

ϵ _ _ _ (Scale k c, s) = pure $ obs (k,s) `MulF` claim (c,s)
  where obs = pure . Right
        claim = pure . Left

ϵ _ _ _ (And c c' cs, s) = pure . SumF $ fmap (claim . (, s)) (c :: c' :: cs)
  where claim = pure . Left

ϵ _ _ _ (Or c c' cs, s) = pure . MaxF $ fmap (claim . (, s)) (c :: c' :: cs)
  where claim = pure . Left

ϵ spot t ccy (When pred c, s) | beforeOrAtToday t τ == Some True = ϵ spot t ccy (c, τ)
  where τ = extend pred s
-- ^ the acquisition time of the inner contract is known and not in the future

ϵ _ t ccy (When pred c, s) = pure $ MulF (ex (disc * claim (c,τ)) τ filtration) $ inv disc
  where τ = extend pred s
        filtration = case s of
          AtInequality _ -> s -- acquisition time of the outer contract is unknown
          other -> extend (TimeGte t) s -- acquisition time of the outer contract is known
        claim = pure . Left
        disc = Free . ProcF $ Disc ccy
        x * y = Free $ MulF x y
        ex e τ f = Free $ E_F e τ f
        inv = Free . InvF
-- ^ the acquisition time of the inner contract is either unknown or known but in the future

ϵ spot t ccy (Cond pred c1 c2, s) | beforeOrAtToday t s == Some True = do
  let
    Some obsTime = resolve s
  predicate <- compare spot pred obsTime
  if predicate then ϵ spot t ccy (c1, s) else ϵ spot t ccy (c2, s)
-- ^ the acquisition time of the `Cond` node is known and not in the future
-- potentially we could replace this by a 1 * if we want to avoid the recursive call inside the RV-coalgebra

ϵ spot t ccy (Cond pred c1 c2, s) =
  let
    v1 = ind pred * claim (c1,s)
    v2 = (one - ind pred) * claim (c2,s)
  in
    pure $ SumF [v1, v2]
  where claim = pure . Left
        x - y = Free $ SumF [x, (Free $ NegF y)]
        x * y = Free $ MulF x y
        ind = Free . I_F
        one = Free $ ConstF munit
-- ^ the acquisition time of the inner contract is either unknown or known but in the future
-- Value is ind(p) * c1 + (1 - ind(p)) * c2 where p is the boolean process implied by the inequality

-- DONE:
-- zero
-- one
-- give
-- scale
-- when
-- and
-- cond

-- MISSING :
-- or
-- anytime
-- until
ϵ _ _ _ _ = abort "Unsupported primitive"

-- TODO how do we calculate value given initial acquisition time? We need to discount as of today so probably need to introduce an extra discount term disc s / disc t initially ...

-- | HIDE
-- Carrier of the CV-coalgebra ϵ ||| υ
type Carrier t x a o = Either (Claim t x a o, AcquisitionTime t x o) (O.Observation t x o, AcquisitionTime t x o)





