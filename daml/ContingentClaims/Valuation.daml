{-# LANGUAGE TypeOperators #-}
{-# LANGUAGE NoImplicitPrelude #-}
module ContingentClaims.Valuation where

import ContingentClaims.Claim (Claim(..), ClaimF(..))
import ContingentClaims.Claim qualified as C
-- import ContingentClaims.Math.Random (_E, cdf)
-- import ContingentClaims.Math.Random qualified as Random
import ContingentClaims.Math.Ring
import ContingentClaims.Math.Ring qualified as Ring (RingF(OneF, ZeroF), negate)
import ContingentClaims.Math.Indicator
import ContingentClaims.MathML.XML
import ContingentClaims.MathML.Presentation
import ContingentClaims.Observation (Observation(..), Key)
import ContingentClaims.Math.ADTaLaCarte
import Daml.Control.Recursion (Fix(..),Recursive(..))
import Daml.Data.Functor.Const (Const(..))
import ContingentClaims.Math.Lit

import Prelude hiding ((-),(+),(*))

type ExprF = ConstF :+: IndicatorF :+: VarF :+: RingF

-- Fundamental Asset Pricing Formula
fapf : Show a => (a -> t -> Fix ExprF) -> (t -> Key -> Fix ExprF) -> Claim Observation t a -> Fix ExprF
fapf disc spot = cata (fapf' disc spot)

fapf' : Show a
      => (a -> t -> Fix ExprF)
      -> (t -> Key -> Fix ExprF)
      -> ClaimF Observation t a (Fix ExprF)
      -> Fix ExprF
fapf' _ _ (OrF c c') = max c c' where
  max a b = a * indicator a b + b * indicator b a
fapf' disc _ (WhenF (DateEqu (DateIdentity, DateConst t)) c) = c -- FIXME, somehow 'bind' t
fapf' _ _ (ScaleF obs c) = rv obs * c
fapf' disc _ (C.OneF asset) = point (show asset)

rv : Observation t Decimal -> Fix ExprF
rv (DecimalConst x) = point x
rv (DecimalObs key) = undefined
rv (DecimalLte (lhs, rhs)) = undefined
rv (DecimalEqu (lhs, rhs)) = undefined
rv (DecimalAdd (lhs, rhs)) = rv lhs + rv rhs
rv (DecimalNeg (lhs)) = Ring.negate (rv lhs)
rv (DecimalMul (lhs, rhs)) = undefined
rv (DecimalDiv (lhs, rhs)) = undefined
rv (BoolConst b) = undefined
rv (DateIdentity) = undefined
rv (DateConst t) = undefined
rv (DateLte (lhs, rhs)) = undefined
rv (DateEqu (lhs, rhs)) = undefined

instance ToXML a => ToXML (RingF a) where
  toXML Ring.ZeroF = mn "0"
  toXML Ring.OneF = mn "1"
  toXML (AddF x y) = toXML x <> mo "+" <> toXML y
  -- toXML (AddF x (NegF y)) = toXML x <> mo "-" <> toXML y
  toXML (NegF x) = mo "-" <> toXML x
  toXML (MulF x y) = toXML x <> toXML y

-- TODO : specialise for Decimal and String
instance Show a => ToXML (Const a x) where
  toXML (Const d) = show d
