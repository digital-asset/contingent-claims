{-# LANGUAGE TypeOperators #-}
{-# LANGUAGE NoImplicitPrelude #-}
module ContingentClaims.Valuation where

import ContingentClaims.Claim (Claim(..), ClaimF(..))
import ContingentClaims.Claim qualified as Claim
-- import ContingentClaims.Math.Random (_E, cdf)
-- import ContingentClaims.Math.Random qualified as Random
import ContingentClaims.Math.Ring
import ContingentClaims.Math.Ring qualified as Ring (RingF(OneF, ZeroF), negate, zero)
import ContingentClaims.Math.Indicator
import ContingentClaims.MathML.XML
import ContingentClaims.MathML.Presentation
import ContingentClaims.Observation (Observation(..), Key)
import ContingentClaims.Math.ADTaLaCarte
import Daml.Control.Recursion (Fix(..),Recursive(..))
import Daml.Data.Functor.Const (Const(..))
import ContingentClaims.Math.Lit
import DA.Map (insert)

import Prelude hiding ((-),(+),(*), elem)

type ExprF = ConstF :+: IndicatorF :+: VarF :+: RingF

-- Fundamental Asset Pricing Formula
fapf : Show a 
     => (a -> t -> Fix ExprF) 
     -> (t -> Key -> Fix ExprF) 
     -> Claim Observation t a 
     -> Fix ExprF
fapf disc spot = cata (fapf' disc spot)

fapf' : Show a
      => (a -> t -> Fix ExprF)
      -> (t -> Key -> Fix ExprF)
      -> ClaimF Observation t a (Fix ExprF)
      -> Fix ExprF
fapf' _ _ (OrF c c') = max c c' where
  max a b = a * indicator a b + b * indicator b a
fapf' disc _ (WhenF (DateEqu (DateIdentity, DateConst t)) c) = c -- FIXME, somehow 'bind' t
fapf' _ _ (ScaleF obs c) = rv obs * c
fapf' disc _ (Claim.OneF asset) = point (show asset)
fapf' _ _ Claim.ZeroF = Ring.zero

rv : Observation t Decimal -> Fix ExprF
rv (DecimalConst x) = point x
rv (DecimalObs key) = point key
rv (DecimalLte (lhs, rhs)) = error "rv: undefined DecimalLte case"
rv (DecimalEqu (lhs, rhs)) = error "rv: undefined DecimalEqu case"
rv (DecimalAdd (lhs, rhs)) = rv lhs + rv rhs
rv (DecimalNeg (lhs)) = Ring.negate (rv lhs)
rv (DecimalMul (lhs, rhs)) = rv lhs * rv rhs
rv (DecimalDiv (lhs, rhs)) = error "rv: undefined DecimalDiv case"
rv (BoolConst b) = error "rv: undefined BoolConst"
rv (DateIdentity) = error "rv: undefined DateIdentity"
rv (DateConst t) = error "rv: undefined DateConst"
rv (DateLte (lhs, rhs)) = error "rv: undefined DateLte"
rv (DateEqu (lhs, rhs)) = error "rv: undefined DateEqu"

instance ToXML f => ToXML (RingF f) where
  toXML Ring.ZeroF = mn "0"
  toXML Ring.OneF = mn "1"
  toXML (AddF x y) = toXML x <> mo "+" <> toXML y
  -- toXML (AddF x (NegF y)) = toXML x <> mo "-" <> toXML y
  toXML (NegF x) = mo "-" <> toXML x
  toXML (MulF x y) = toXML x <> toXML y

instance ToXML (Const Text x) where
  toXML (Const s) = mi s

instance ToXML (Const Decimal x) where
  toXML (Const d) = mn . show $ d

instance ToXML f => ToXML (IndicatorF f) where
  toXML (IndicatorF x y) = msub $ _1 <> subscript 
    where _1 = elem "mo" "1" $ insert "mathvariant" "double-struck" mempty
          subscript = mrow $ toXML x <> mo "<" <> toXML y
                          
