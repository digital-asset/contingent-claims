{-# LANGUAGE TypeOperators #-}
{-# LANGUAGE NoImplicitPrelude #-}
module ContingentClaims.Valuation where

import ContingentClaims.Claim (Claim(..), ClaimF(..))
import ContingentClaims.Claim qualified as Claim
import ContingentClaims.Math.Random (_E)
import ContingentClaims.Math.Random qualified as Random (VariableF(..))
import ContingentClaims.Math.Ring
import ContingentClaims.Math.Ring qualified as Ring (RingF(OneF, ZeroF), negate, zero)
import ContingentClaims.Math.Indicator
import ContingentClaims.MathML.XML
import ContingentClaims.MathML.Presentation
import ContingentClaims.Observation (Observation(..), Key)
import ContingentClaims.Math.ADTaLaCarte
import ContingentClaims.Math.ADTaLaCarte qualified as Fix
import Daml.Control.Recursion (Fix(..),Recursive(..))
import Daml.Data.Functor.Const (Const(..))
import ContingentClaims.Math.Lit
import DA.Map (insert)

import Prelude hiding ((-),(+),(*), elem)

type ExprF = Random.VariableF :+: ConstF :+: IndicatorF :+: VarF :+: RingF

-- Fundamental Asset Pricing Formula
fapf : (a -> Key)
     -> (Key -> Fix ExprF)
     -> Claim Observation t a 
     -> Fix ExprF
fapf render env = _E . cata (fapf' render env)

fapf' : (a -> Key)
      -> (Key -> Fix ExprF)
      -> ClaimF Observation t a (Fix ExprF)
      -> Fix ExprF
fapf' _ _ (OrF c c') = max c c' where
  max a b = a * indicator a b + b * indicator b a
fapf' _ _ (WhenF (DateEqu (DateIdentity, DateConst t)) c) = c -- FIXME, somehow 'bind' t
fapf' _ _ (ScaleF obs c) = rv obs * c
fapf' render _ (Claim.OneF asset) = point (render asset)
fapf' _ _ Claim.ZeroF = Ring.zero

rv : Observation t Decimal -> Fix ExprF
rv (DecimalConst x) = point x
rv (DecimalObs key) = point key
rv (DecimalLte (lhs, rhs)) = error "rv: undefined DecimalLte case"
rv (DecimalEqu (lhs, rhs)) = error "rv: undefined DecimalEqu case"
rv (DecimalAdd (lhs, rhs)) = rv lhs + rv rhs
rv (DecimalNeg (lhs)) = Ring.negate (rv lhs)
rv (DecimalMul (lhs, rhs)) = rv lhs * rv rhs
rv (DecimalDiv (lhs, rhs)) = error "rv: undefined DecimalDiv case"
rv (BoolConst b) = error "rv: undefined BoolConst"
rv (DateIdentity) = error "rv: undefined DateIdentity"
rv (DateConst t) = error "rv: undefined DateConst"
rv (DateLte (lhs, rhs)) = error "rv: undefined DateLte"
rv (DateEqu (lhs, rhs)) = error "rv: undefined DateEqu"

instance ToXML f => ToXML (Random.VariableF f) where
  toXML (Random.DistributionF x) = mo "N" <> bracket "(" ")" (toXML x)
  toXML (Random.ExpectationF x) = _E <> bracket "[" "]" p
    where _E = elem "mo" "E" $ insert "mathvariant" "double-struck" mempty
          p = toXML x

instance (ToXML (Fix f), RingF :â‰º: f)  => ToXML (RingF (Fix f)) where
  toXML Ring.ZeroF = mn "0"
  toXML Ring.OneF = mn "1"
  toXML (AddF x (Fix.project -> Some (NegF y))) = toXML x <> mo "+" <> toXML y
  toXML (AddF x positiveY) = toXML x <> mo "-" <> toXML positiveY
  toXML (NegF x) = mo "-" <> toXML x
  toXML (MulF x y) = maybeBracket x <> maybeBracket y
    where maybeBracket z@(Fix.project -> Some (AddF _ _)) = bracket "(" ")" (toXML z)
          maybeBracket z = toXML z

instance ToXML (Const Text x) where
  toXML (Const s) = mi s

instance ToXML (Const Decimal x) where
  toXML (Const d) = mn . show $ d

instance ToXML f => ToXML (IndicatorF f) where
  toXML (IndicatorF x y) = msub $ _1 <> subscript 
    where _1 = elem "mo" "1" $ insert "mathvariant" "double-struck" mempty
          subscript = mrow $ toXML x <> mo "<" <> toXML y
                          
