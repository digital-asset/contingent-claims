{-# LANGUAGE TypeOperators #-}
{-# LANGUAGE NoImplicitPrelude #-}
module ContingentClaims.Valuation where

import ContingentClaims.Claim (Claim(..), ClaimF(..))
import ContingentClaims.Claim qualified as Claim
import ContingentClaims.Math.Random (_E)
import ContingentClaims.Math.Random qualified as Random (VariableF(..))
import ContingentClaims.Math.Ring
import ContingentClaims.Math.Ring qualified as Ring (RingF(OneF, ZeroF), negate, zero)
import ContingentClaims.Math.Indicator
import ContingentClaims.MathML.XML
import ContingentClaims.MathML.Presentation
import ContingentClaims.Observation (Observation(..), Key)
import ContingentClaims.Math.ADTaLaCarte
import ContingentClaims.Math.ADTaLaCarte qualified as Fix (project)
import Daml.Control.Recursion (Fix(..),Recursive(..))
import Daml.Data.Functor.Const (Const(..))
import ContingentClaims.Math.Lit
import DA.Map (insert)

import Prelude hiding ((-),(+),(*), elem)

type ExprF = Random.VariableF :+: ConstF :+: IndicatorF :+: VarF :+: RingF

instance Functor f => Recursive (Fix f) f where
  project = unfix

-- Fundamental Asset Pricing Formula
fapf : (a -> Key)
     -> (Key -> Fix ExprF)
     -> Claim Observation t a 
     -> Fix ExprF
fapf render env
  = _E 
  . cata (\expr -> optional (Fix expr) prodIdempotency (Fix.project (Fix expr)))
  . cata (fapf' render env)

{- TODO: it's really annoying that we can't fuse these ^^ operations. This is
because 'fapf', in the `OrF` production, generates a subtree of multiple nodes,
with an `AddF` at the root. Any algebra composed with this will only look at
the top level node, so e.g. we can't reduce multiplication by zero, because `MulF`
is one more level down. Perhaps this should be co-recursive instead? -}

-- Helper function to allow composing algebras; this allows folding in a single pass
fuse : forall g . g :≺: ExprF => (g (Fix ExprF) -> Fix ExprF) -> Fix ExprF -> Fix ExprF 
fuse ff f = optional f ff (Fix.project f)

fapf' : (a -> Key)
      -> (Key -> Fix ExprF)
      -> ClaimF Observation t a (Fix ExprF)
      -> Fix ExprF
fapf' _ _ (OrF c c') = max c c' where
  max a b = a * indicator a b + b * indicator b a
fapf' _ _ (WhenF (DateEqu (DateIdentity, DateConst t)) c) = c -- FIXME, somehow 'bind' t
fapf' _ _ (ScaleF obs c) = rv obs * c
fapf' render _ (Claim.OneF asset) = point (render asset)
fapf' _ _ Claim.ZeroF = Ring.zero

prodIdempotency : RingF (Fix ExprF) -> Fix ExprF
prodIdempotency (MulF (Fix.project -> Some (Ring.ZeroF)) _) = zero
prodIdempotency (MulF _ (Fix.project -> Some (Ring.ZeroF))) = zero
prodIdempotency other = inject other

addIdentity : RingF (Fix ExprF) -> Fix ExprF
addIdentity (AddF (Fix.project -> Some (Ring.ZeroF)) x) = x
addIdentity (AddF x (Fix.project -> Some (Ring.ZeroF))) = x
addIdentity other = inject other

prodIdentity : RingF (Fix ExprF) -> Fix ExprF
prodIdentity (MulF (Fix.project -> Some (Ring.OneF)) x) = x
prodIdentity (MulF x (Fix.project -> Some (Ring.OneF))) = x
prodIdentity other = inject other

rv : Observation t Decimal -> Fix ExprF
rv (DecimalConst x) = point x
rv (DecimalObs key) = point key
rv (DecimalLte (lhs, rhs)) = error "rv: undefined DecimalLte case"
rv (DecimalEqu (lhs, rhs)) = error "rv: undefined DecimalEqu case"
rv (DecimalAdd (lhs, rhs)) = rv lhs + rv rhs
rv (DecimalNeg (lhs)) = Ring.negate (rv lhs)
rv (DecimalMul (lhs, rhs)) = rv lhs * rv rhs
rv (DecimalDiv (lhs, rhs)) = error "rv: undefined DecimalDiv case"
rv (BoolConst b) = error "rv: undefined BoolConst"
rv (DateIdentity) = error "rv: undefined DateIdentity"
rv (DateConst t) = error "rv: undefined DateConst"
rv (DateLte (lhs, rhs)) = error "rv: undefined DateLte"
rv (DateEqu (lhs, rhs)) = error "rv: undefined DateEqu"

instance ToXML f => ToXML (Random.VariableF f) where
  toXML (Random.DistributionF x) = mo "N" <> bracket "(" ")" (toXML x)
  toXML (Random.ExpectationF x) = _E <> bracket "[" "]" p
    where _E = elem "mo" "E" $ insert "mathvariant" "double-struck" mempty
          p = toXML x

instance (ToXML (Fix f), RingF :≺: f)  => ToXML (RingF (Fix f)) where
  toXML Ring.ZeroF = mn "0"
  toXML Ring.OneF = mn "1"
  toXML (AddF x (Fix.project -> Some (NegF y))) = toXML x <> mo "+" <> toXML y
  toXML (AddF x positiveY) = toXML x <> mo "-" <> toXML positiveY
  toXML (NegF x) = mo "-" <> toXML x
  toXML (MulF x y) = maybeBracket x <> maybeBracket y
    where maybeBracket z@(Fix.project -> Some (AddF _ _)) = bracket "(" ")" (toXML z)
          maybeBracket z = toXML z

instance ToXML (Const Text x) where
  toXML (Const s) = mi s

instance ToXML (Const Decimal x) where
  toXML (Const d) = mn . show $ d

instance ToXML f => ToXML (IndicatorF f) where
  toXML (IndicatorF x y) = msub $ _1 <> subscript 
    where _1 = elem "mo" "1" $ insert "mathvariant" "double-struck" mempty
          subscript = mrow $ toXML x <> mo "<" <> toXML y
                          
