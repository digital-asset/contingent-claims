--
-- Copyright (c) 2021, Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0
--

module ContingentClaims.Claim where

import Prelude hiding (or, and)
import Daml.Control.Recursion
import ContingentClaims.Claim.Serializable qualified as Serialized
import ContingentClaims.Observation (Observation)
-- import qualified ContingentClaims.Observation as Observation (expiry)
import ContingentClaims.Observable (Inequality)
import DA.Set qualified as Set
import DA.Foldable (Foldable(..))
import DA.Traversable (Traversable(..))

type T = Claim
type F = ClaimF

-- TODO: f should depend on t ?

-- | Used to model cashflows of instruments. 
-- See [quickstart](../QUICKSTART.md) for detailed explanation.
-- In Petyon-Jones' paper, this is called 'Contract'.
-- We renamed it to avoid ambiguity.
-- * `f`, `t` and `x` correspond to the `Observable`, it's input and output, respectively.
-- * `a` is the representation of an asset, e.g. a `Text` ISIN code.
data Claim f t x a
  = Zero
      -- ^ Represents an absence of claims.
  | One a
      -- ^ The bearer acquires one unit of `a` *immediately*.
  | Give (Claim f t x a)
      -- ^ The obligations of the bearer and issuer are revesed.
  | And with lhs: Claim f t x a, rhs: Claim f t x a
      -- ^ Used to combine multiple rights together.
  | Or with lhs: Claim f t x a, rhs: Claim f t x a
      -- ^ Gives the bearer the right to choose between two claims.
  | Cond with predicate: Inequality f t x, success: Claim f t x a, failure: Claim f t x a --TODO rename predicate -> `lte` or `inequality`
      -- ^ Gives the bearer the right to the first claim if `predicate` is true, else the second claim.
  | Scale with k: f t x, claim: Claim f t x a
      -- ^ Multiplies the `claim` by `k` (which can be non-detrerministic).
  | When with predicate: Inequality f t x, claim: Claim f t x a
      -- ^ Defers the acquisition of `claim` until *the first instant* that `predicate` is true.

{-
-- | Return the upper time bound of the obligation; `None` if it cannot be determined.
-- This is called `horizon` in the original paper.
expiry : forall t a . Ord t => Claim Observation t a -> Optional t
expiry = cata \case
           ZeroF -> None
           OneF _ -> None
           GiveF t -> t
           AndF t t' -> liftA2 max t t'
           OrF t t' -> liftA2 max t t'
           CondF _ t t' -> liftA2 max t t'
           ScaleF _ t -> t
           WhenF p _ -> Observation.expiry p
--           AnytimeF p _ -> Observation.expiry p
--           UntilF p _ -> Observation.expiry p
-}

-- TODO: not sure these make sense
executorOf : Party -> Party -> Claim f t x a -> Set.Set Party
executorOf bearer cpty = cata \case
  ZeroF -> mempty
  OneF _ -> Set.singleton bearer
  GiveF p -> case Set.toList p of
    [p] -> Set.singleton $ if p == bearer then cpty else bearer
    [] -> mempty
    _ -> Set.fromList [bearer, cpty]
  AndF p p' -> p <> p'
  OrF p p' -> p <> p'
  ScaleF _ p -> p
  CondF _ p p' -> p <> p'
  WhenF _ p -> p
--  AnytimeF _ p -> p
--  UntilF _ p -> p

-- TODO: not sure these make sense
isBearerExecutor : forall f t x a . Claim f t x a -> Bool
isBearerExecutor = cata \case
                    OneF _ -> True
                    GiveF p -> not p
                    ScaleF _ p -> True
                    AndF p _ -> True
                    WhenF p _ -> True
                    ZeroF -> error "Undefined: ZeroF"
                    _ -> error "Undefined: isBearerExecutor"

-- | Converts a `Serialized.Claim` read from ledger, to a more general `Claim`, for use with `Daml.Control.Recursion`.
deserialize : Serialized.Claim t x a -> Claim Observation t x a
deserialize = ana deserialize' 

-- | F-algebra for `deserialize`; it can be composed in unfolds.
deserialize' : Serialized.Claim t x a -> ClaimF Observation t x a (Serialized.Claim t x a)
deserialize' Serialized.Zero = ZeroF
deserialize' (Serialized.One a) = OneF a
deserialize' (Serialized.Give c) = GiveF c
deserialize' (Serialized.And [c]) = deserialize'  c
deserialize' (Serialized.And (c :: cs)) = AndF c (Serialized.And cs)
deserialize' (Serialized.And []) = error "deserialize: Malformed `And` (should have at least two elements)"
deserialize' (Serialized.Or c c') = OrF c c'
deserialize' (Serialized.Cond k c c') = CondF k c c'
deserialize' (Serialized.Scale k c) = ScaleF k c
deserialize' (Serialized.When p c) = WhenF p c
--  Serialized.Anytime p c = AnytimeF p c
--  Serialized.Until p c = UntilF p c

-- | Converts a `Claim` into a `Serializable.Claim`, so it can be written to the ledger.
serialize : Claim Observation t x a -> Serialized.Claim t x a
serialize = histo serialize'

-- | F-coalgebra for `serialize`; it can be composed with other folds.
serialize' : ClaimF Observation t x a (Cofree (ClaimF Observation t x a) (Serialized.Claim t x a)) -> Serialized.Claim t x a 
serialize' ZeroF = Serialized.Zero
serialize' (OneF a) = Serialized.One a
serialize' (GiveF c) = Serialized.Give c.attribute
serialize' (AndF c (Cofree (Serialized.And cs) _) ) = Serialized.And $ c.attribute :: cs
serialize' (AndF c c') = Serialized.And [c.attribute, c'.attribute]
serialize' (OrF c c') = Serialized.Or c.attribute c'.attribute
serialize' (CondF k c c') = Serialized.Cond k c.attribute c'.attribute
serialize' (ScaleF k c) = Serialized.Scale k c.attribute
serialize' (WhenF p c) = Serialized.When p c.attribute
--  Anytime p c -> Serialized.AnytimeF p c
--  Until p c -> Serialized.UntilF p c

-- | Unfixed version of `Claim`, for use with `Daml.Control.Recursion`.
data ClaimF f t x a b
  = ZeroF
  | OneF a
  | GiveF b
  | AndF with lhs: b, rhs: b
  | OrF with lhs: b, rhs: b
  | CondF with predicate: Inequality f t x, success: b, failure: b
  | ScaleF with k: f t x, claim: b
  | WhenF with predicate: Inequality f t x, claim: b
--  | AnytimeF with predicate: (f t Bool), claim: b
--  | UntilF with predicate: (f t Bool), claim: b
  deriving (Functor)

-- TODO: rename variables to be consistent with the types
instance Recursive (Claim f t x a) (ClaimF f t x a) where
  project Zero = ZeroF
  project (One a) = OneF a
  project (Give c) = GiveF c
  project (And c c') = (AndF c c')
  project (Or c c') = (OrF c c')
  project (Cond a c c') = CondF a c c'
  project (Scale k a) = ScaleF k a
  project (When o a) = WhenF o a
--  project (Anytime o a) = AnytimeF o a
--  project (Until o x) = UntilF o x

instance Corecursive (Claim f t x a) (ClaimF f t x a) where
  embed ZeroF = Zero
  embed (OneF x) = One x
  embed (GiveF a) = Give a
  embed (AndF a b) = (And a b)
  embed (OrF a b) = (Or a b)
  embed (CondF x a b) = Cond x a b
  embed (ScaleF k x) = Scale k x
  embed (WhenF o x) = When o x
--  embed (AnytimeF o x) = Anytime o x
--  embed (UntilF o x) = Until o x

instance Foldable (ClaimF f t x a) where
  foldr _ seed ZeroF = seed
  foldr _ seed (OneF _) = seed
  foldr f seed (GiveF c) = f c seed
  foldr f seed (WhenF _ c) = f c seed
  foldr f seed (ScaleF _ c) = f c seed
  foldr f seed (AndF c c') = f c $ f c' seed
  foldr f seed (OrF c c') = f c $ f c' seed
  foldr f seed (CondF _ c c') = f c $ f c' seed

instance Traversable (ClaimF g t x b) where
  sequence ZeroF = pure ZeroF
  sequence (OneF asset) = pure $ OneF asset
  sequence (GiveF fa) = GiveF <$> fa
  sequence (WhenF p fa) = WhenF p <$> fa
  sequence (ScaleF p fa) = ScaleF p <$> fa
  sequence (AndF fa fa') = AndF <$> fa <*> fa'
  sequence (OrF fa fa') = OrF <$> fa <*> fa'
  sequence (CondF p fa fa') = CondF p <$> fa <*> fa'
