--
-- Copyright (c) 2021, Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0
--

module ContingentClaims.Claim where

import Prelude hiding (or, and)
import Daml.Control.Arrow (Kleisli(..), arr)
import Daml.Control.Recursion
import ContingentClaims.Observation (Observation)
import ContingentClaims.Observation qualified as Observation
import DA.Foldable (Foldable(..))
import DA.Traversable (Traversable(..))

type T = Claim
type F = ClaimF

-- TODO: f should depend on t ?

-- | Used to model cashflows of instruments.
-- See [quickstart](../QUICKSTART.md) for detailed explanation.
-- In Petyon-Jones' paper, this is called 'Contract'.
-- We renamed it to avoid ambiguity.
-- * `t` and `x` respectively correspond to the `Observation`s, input type and the resulting output type.
-- * `a` is the representation of an asset, e.g. a `Text` ISIN code.
data Claim t x a
  = Zero
      -- ^ Represents an absence of claims.
  | One a
      -- ^ The bearer acquires one unit of `a` *immediately*.
  | Give (Claim t x a)
      -- ^ The obligations of the bearer and issuer are revesed.
  | And with lhs: Claim t x a, rhs: Claim t x a
      -- ^ Used to combine multiple rights together.
  | Or with lhs: Claim t x a, rhs: Claim t x a
      -- ^ Gives the bearer the right to choose between two claims.
  | Cond with predicate: Inequality t x a, success: Claim t x a, failure: Claim t x a
      -- ^ Gives the bearer the right to the first claim if `predicate` is true, else the second claim.
  | Scale with k: Observation t x a, claim: Claim t x a
      -- ^ Multiplies the `claim` by `k` (which can be non-deterministic).
  | When with predicate: Inequality t x a, claim: Claim t x a
      -- ^ Defers the acquisition of `claim` until *the first instant* that `predicate` is true.
  | Anytime with predicate: Inequality t x a, claim: Claim t x a
      -- ^ Like `When`, but valid any time the predicate is true (not just infinium).
  | Until with predicate: Inequality t x a, claim: Claim t x a
      -- ^ Expires said claim on the *first instant* that `predicate` is true.
  deriving (Show, Eq)

-- | Replace parameters in an `Claim` with actual values.
mapParams :  (t -> i)
          -> (i -> t)
          -> (a -> a')
          -> (x -> x')
          -> Claim i x a -> Claim t x' a'
mapParams ft' ft fk fv =
  let f = Observation.mapParams ft' fk fv
  in cata \case
    ZeroF -> Zero
    OneF a -> One $ fk a
    GiveF c -> Give c
    AndF c c' -> And c c'
    OrF c c' -> Or c c'
    CondF (Lte (x, x')) c c' -> Cond (Lte(f x, f x')) c c'
    CondF (TimeGte t) c c' -> Cond (TimeGte (ft t)) c c'
    ScaleF k c -> Scale (f k) c
    WhenF (Lte (x, x')) c -> When (Lte (f x, f x')) c
    WhenF (TimeGte t) c -> When (TimeGte (ft t)) c
    AnytimeF (Lte (x, x')) c -> Anytime (Lte (f x, f x')) c
    AnytimeF (TimeGte t) c -> Anytime (TimeGte (ft t)) c
    UntilF (Lte (x, x')) c -> Until (Lte (f x, f x')) c
    UntilF (TimeGte t) c -> Until (TimeGte (ft t)) c

-- | Unfixed version of `Claim`, for use with `Daml.Control.Recursion`.
data ClaimF t x a b
  = ZeroF
  | OneF a
  | GiveF b
  | AndF with lhs: b, rhs: b
  | OrF with lhs: b, rhs: b
  | CondF with predicate: Inequality t x a, success: b, failure: b
  | ScaleF with k: Observation t x a, claim: b
  | WhenF with predicate: Inequality t x a, claim: b
  | AnytimeF with predicate: Inequality t x a, claim: b
  | UntilF with predicate: Inequality t x a, claim: b
  deriving (Functor)

instance Recursive (Claim t x a) (ClaimF t x a) where
  project Zero = ZeroF
  project (One a) = OneF a
  project (Give c) = GiveF c
  project (And c c') = (AndF c c')
  project (Or c c') = (OrF c c')
  project (Cond p c c') = CondF p c c'
  project (Scale k c) = ScaleF k c
  project (When p c) = WhenF p c
  project (Anytime p c) = AnytimeF p c
  project (Until p c) = UntilF p c

instance Corecursive (Claim t x a) (ClaimF t x a) where
  embed ZeroF = Zero
  embed (OneF x) = One x
  embed (GiveF a) = Give a
  embed (AndF c c') = (And c c')
  embed (OrF c c') = (Or c c')
  embed (CondF p c c') = Cond p c c'
  embed (ScaleF k c) = Scale k c
  embed (WhenF p c) = When p c
  embed (AnytimeF p c) = Anytime p c
  embed (UntilF p c) = Until p c

instance Foldable (ClaimF t x a) where
  foldr _ seed ZeroF = seed
  foldr _ seed (OneF _) = seed
  foldr f seed (GiveF c) = f c seed
  foldr f seed (WhenF _ c) = f c seed
  foldr f seed (ScaleF _ c) = f c seed
  foldr f seed (AndF c c') = f c $ f c' seed
  foldr f seed (OrF c c') = f c $ f c' seed
  foldr f seed (CondF _ c c') = f c $ f c' seed
  foldr f seed (AnytimeF _ c) = f c seed
  foldr f seed (UntilF _ c) = f c seed

instance Traversable (ClaimF t x b) where
  sequence ZeroF = pure ZeroF
  sequence (OneF asset) = pure $ OneF asset
  sequence (GiveF fa) = GiveF <$> fa
  sequence (WhenF p fa) = WhenF p <$> fa
  sequence (ScaleF p fa) = ScaleF p <$> fa
  sequence (AndF fa fa') = AndF <$> fa <*> fa'
  sequence (OrF fa fa') = OrF <$> fa <*> fa'
  sequence (CondF p fa fa') = CondF p <$> fa <*> fa'
  sequence (AnytimeF p fa) = AnytimeF p <$> fa
  sequence (UntilF p fa) = UntilF p <$> fa

-- Inequality --

-- | This is either `time ≥ t | f t x ≤ f t x`
data Inequality t x a = TimeGte t | Lte (Observation t x a, Observation t x a) 
     deriving (Eq, Show)

-- | Observable that is true on the passed time. i.e. identity for the time observable.
at : t -> Inequality t x a
at t = TimeGte t

infix 4 <=
-- | `import Prelude hiding ((<=))` in order to use this.
(<=) : Observation t x a -> Observation t x a -> Inequality t x a
(<=) = curry Lte

-- | Reify the `Observable.Inequality` into a Kleisli function.
compare : (Ord t, Ord x, Number x, Divisible x, Action m) => (a -> t -> m x) -> Inequality t x a -> Kleisli m t Bool
compare doObserve (Lte (f, f')) = liftA2 (Prelude.<=) (Observation.eval doObserve f) (Observation.eval doObserve f')
compare _ (TimeGte t) = arr (>= t)
