--
-- Copyright (c) 2021, Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0
--

module ContingentClaims.Claim where

import Prelude hiding (or, and)
import Daml.Control.Recursion
import ContingentClaims.Claim.Serializable qualified as Serialized
import ContingentClaims.Observation (Observation)
import qualified ContingentClaims.Observation as Observation (expiry)
import DA.Set qualified as Set
import DA.Foldable (Foldable(..))
import DA.Traversable (Traversable(..))

type T = Claim
type F = ClaimF

-- TODO: f should depend on t ?

-- | Used to model cashflows of instruments. 
-- See [quickstart](../QUICKSTART.md) for detailed explanation.
-- In Petyon-Jones' paper, this is called 'Contract'.
-- We renamed it to avoid ambiguity
-- * `f` is the effect, e.g. `(->)`
-- * `t` is time e.g. `Date`
-- * `a` is the asset
data Claim f t a
  = Zero
      -- ^ Represents an absence of claims.
  | One a
      -- ^ The bearer acquires one unit of `a` *immediately*.
  | Give (Claim f t a)
      -- ^ The obligations of the bearer and issuer are revesed.
  | And with lhs: Claim f t a, rhs: Claim f t a
      -- ^ Used to combine multiple rights together.
  | Or with lhs: Claim f t a, rhs: Claim f t a
      -- ^ Gives the bearer the right to choose between two claims.
  | Cond with predicate: f t Bool, success: Claim f t a, failure: Claim f t a
      -- ^ Gives the bearer the right to the first claim if `predicate` is true, else the second claim.
  | Scale with k: f t Decimal, claim: Claim f t a
      -- ^ Multiplies the `claim` by `k` (which can be non-detrerministic).
  | When with predicate: f t Bool, claim: Claim f t a
      -- ^ Defers the acquisition of `claim` until *the first instant* that `predicate` is true.

--  | Anytime with predicate: f t Bool, claim: Claim f t a
--  | Until with predicate: f t Bool, claim: Claim f t a

-- FIXME: why doesn't this work? Consider removing these, as we use mostly higher-level combinators.
-- zero : Claim f t a
-- zero = Zero

one ccy = One ccy

give x = Give x

and c1 c2 = And c1 c2

or c1 c2 = Or c1 c2

cond p c1 c2 = Cond p c1 c2

scale k c1 = Scale k c1

when o c1 = When o c1

-- anytime o c1 = Anytime o c1

-- until o c1 = Until o c1

-- | Return the upper time bound of the obligation; `None` if it cannot be determined.
-- This is called `horizon` in the original paper.
expiry : forall t a . Ord t => Claim Observation t a -> Optional t
expiry = cata \case
           ZeroF -> None
           OneF _ -> None
           GiveF t -> t
           AndF t t' -> liftA2 max t t'
           OrF t t' -> liftA2 max t t'
           CondF _ t t' -> liftA2 max t t'
           ScaleF _ t -> t
           WhenF p _ -> Observation.expiry p
--           AnytimeF p _ -> Observation.expiry p
--           UntilF p _ -> Observation.expiry p

-- TODO: not sure these make sense
executorOf : Party -> Party -> Claim f t a -> Set.Set Party
executorOf bearer cpty = cata \case
  ZeroF -> mempty
  OneF _ -> Set.singleton bearer
  GiveF p -> case Set.toList p of
    [p] -> Set.singleton $ if p == bearer then cpty else bearer
    [] -> mempty
    _ -> Set.fromList [bearer, cpty]
  AndF p p' -> p <> p'
  OrF p p' -> p <> p'
  ScaleF _ p -> p
  CondF _ p p' -> p <> p'
  WhenF _ p -> p
--  AnytimeF _ p -> p
--  UntilF _ p -> p

-- TODO: not sure these make sense
isBearerExecutor : forall f t a . Claim f t a -> Bool
isBearerExecutor = cata \case
                    OneF _ -> True
                    GiveF p -> not p
                    ScaleF _ p -> True
                    AndF p _ -> True
                    WhenF p _ -> True
                    ZeroF -> error "Undefined: ZeroF"
                    _ -> error "Undefined: isBearerExecutor"

-- | Converts a `Serialized.Claim` read from ledger, to a more general `Claim`, for use with `Daml.Control.Recursion`.
deserialize : Serialized.Claim t a -> Claim Observation t a
deserialize = ana deserialize' 

-- | F-algebra for `deserialize`; it can be composed in unfolds.
deserialize' Serialized.Zero = ZeroF
deserialize' (Serialized.One a) = OneF a
deserialize' (Serialized.Give c) = GiveF c
deserialize' (Serialized.And [c]) = deserialize'  c
deserialize' (Serialized.And (c :: cs)) = AndF c (Serialized.And cs)
deserialize' (Serialized.And []) = error "deserialize: Malformed `And` (should have at least two elements)"
deserialize' (Serialized.Or c c') = OrF c c'
deserialize' (Serialized.Cond k c c') = CondF k c c'
deserialize' (Serialized.Scale k c) = ScaleF k c
deserialize' (Serialized.When p c) = WhenF p c
--  Serialized.Anytime p c = AnytimeF p c
--  Serialized.Until p c = UntilF p c

-- | Converts a `Claim` into a `Serializable.Claim`, so it can be written to the ledger.
serialize : Claim Observation t a -> Serialized.Claim t a
serialize = histo serialize'

-- | F-coalgebra for `serialize`; it can be composed with other folds.
serialize' ZeroF = Serialized.Zero
serialize' (OneF a) = Serialized.One a
serialize' (GiveF c) = Serialized.Give c.attribute
serialize' (AndF c (Cofree (Serialized.And cs) _) ) = Serialized.And $ c.attribute :: cs
serialize' (AndF c c') = Serialized.And [c.attribute, c'.attribute]
serialize' (OrF c c') = Serialized.Or c.attribute c'.attribute
serialize' (CondF k c c') = Serialized.Cond k c.attribute c'.attribute
serialize' (ScaleF k c) = Serialized.Scale k c.attribute
serialize' (WhenF p c) = Serialized.When p c.attribute
--  Anytime p c -> Serialized.AnytimeF p c
--  Until p c -> Serialized.UntilF p c

-- | Unfixed version of `Claim`, for use with `Daml.Control.Recursion`.
data ClaimF f t a x
  = ZeroF
  | OneF a
  | GiveF x
  | AndF with lhs: x, rhs: x
  | OrF with lhs: x, rhs: x
  | CondF with predicate: (f t Bool), success: x, failure: x
  | ScaleF with k: (f t Decimal), claim: x
  | WhenF with predicate: (f t Bool), claim: x
--  | AnytimeF with predicate: (f t Bool), claim: x
--  | UntilF with predicate: (f t Bool), claim: x
  deriving (Functor)

-- TODO: rename variables to be consistent with the types
instance Recursive (Claim f t a) (ClaimF f t a) where
  project Zero = ZeroF
  project (One a) = OneF a
  project (Give c) = GiveF c
  project (And c c') = (AndF c c')
  project (Or c c') = (OrF c c')
  project (Cond a c c') = CondF a c c'
  project (Scale k a) = ScaleF k a
  project (When o a) = WhenF o a
--  project (Anytime o a) = AnytimeF o a
--  project (Until o x) = UntilF o x

instance Corecursive (Claim f t a) (ClaimF f t a) where
  embed ZeroF = Zero
  embed (OneF x) = One x
  embed (GiveF a) = Give a
  embed (AndF a b) = (And a b)
  embed (OrF a b) = (Or a b)
  embed (CondF x a b) = Cond x a b
  embed (ScaleF k x) = Scale k x
  embed (WhenF o x) = When o x
--  embed (AnytimeF o x) = Anytime o x
--  embed (UntilF o x) = Until o x

instance Foldable (ClaimF f t a) where
  foldr _ seed ZeroF = seed
  foldr _ seed (OneF _) = seed
  foldr f seed (GiveF c) = f c seed
  foldr f seed (WhenF _ c) = f c seed
  foldr f seed (ScaleF _ c) = f c seed
  foldr f seed (AndF c c') = f c $ f c' seed
  foldr f seed (OrF c c') = f c $ f c' seed
  foldr f seed (CondF _ c c') = f c $ f c' seed

instance Traversable (ClaimF g t x) where
  sequence ZeroF = pure ZeroF
  sequence (OneF x) = pure $ OneF x
  sequence (GiveF fa) = GiveF <$> fa
  sequence (WhenF p fa) = WhenF p <$> fa
  sequence (ScaleF p fa) = ScaleF p <$> fa
  sequence (AndF fa fa') = AndF <$> fa <*> fa'
  sequence (OrF fa fa') = OrF <$> fa <*> fa'
  sequence (CondF p fa fa') = CondF p <$> fa <*> fa'
