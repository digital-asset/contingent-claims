{-# LANGUAGE ApplicativeDo #-} --for scripts?
{-# LANGUAGE TypeOperators #-}

module DvPExamples where

import Daml.Script

import Prelude hiding (and, or, time, (.), lookup, foldl, merge)
import Obligation
import qualified Obligation.Serializable
import FinancialObligation
import DA.Date (date, Month(..)) --, toDateUTC)
import Category
import DA.Next.Map (Map, MapKey, merge, insert, lookup, fromList)
import DA.Foldable (foldl)
import Recursion
import Kleisli
import Observation
import Observable (PointF)
import Observable qualified as O (pure)
-- import ObservableFunctions

-- Specialized effect-less obligation for DvP
type Monad = Action
type (>=>) = Kleisli Update
type ISIN = Text
type Asset = Either Currency ISIN
-- type Obligations = Obligation (>=>) Date Asset
type Obligations = Obligation.Serializable.T Date Asset

-- ISO Currencies
data Currency = GBP | USD deriving  (Eq, Show)

-- EXample: Note you have to explicitly specify the type

scalek : forall f t a . (PointF f t Decimal) => Decimal -> Obligation f t a -> Obligation f t a
scalek = scale . O.pure

myZcb : Obligation (ObsArrow Asset) Date Asset = zcb (date 2020 Dec 1) 100.0 (Left GBP) 

type Charges = Map Text Decimal -- Used to enrich a payment with commission, market charges etc.
data Claim = Claim deriving (Eq, Show)
data SSI = SSI deriving (Eq, Show)

type CountryISO = Text -- Two char code

template Quote
  with
    isin: ISIN
    quoteDate: Date
    close: Decimal
    source: Party
  where
    signatory source
    key (isin, quoteDate, source) : (ISIN, Date, Party)
    maintainer key._3

template Security
  with
    registrar: Party
    -- csd: Party
    isin: ISIN
    countryOfIssue: CountryISO
    -- currency: Currency
    claims: Obligations
  where
    signatory registrar
    key (isin, registrar) : (ISIN, Party)
    maintainer key._2

template ChargeRule
  with
    operator : Party
    isin: ISIN
    commissionPerNominal: Decimal -- bps
    commissionPerUnit: Decimal
  where
    signatory operator
    key (isin, operator) : (ISIN, Party)
    maintainer key._2

template SettlementRule
  with
    operator: Party
  where
    signatory operator
    key operator: Party
    maintainer key
    controller operator can
      nonconsuming SettlementInstructions : SSI with isin: ISIN
        do
        (_, Security{countryOfIssue}) <- fetchByKey (isin, undefined)
        _ <- pure "Do something to derive the SSIs"
        return SSI
      nonconsuming PaymentInstructions : SSI with ccy: Currency
        do
        return $ case ccy of
          USD -> SSI -- fedwire
          GBP -> SSI -- BACS


modify : forall k v . (MapKey k) => (v -> v) -> k -> Map k v -> Map k v
modify f k kvs = foldl (\kvs v -> insert k (f v) kvs) kvs v
                 where v = f <$> lookup k kvs

isBearerExecutor : forall f t a . Obligation f t a -> Bool
isBearerExecutor = cata \case
                    OneF _ -> True
                    GiveF p -> not p
                    ScaleF _ p -> True
                    AndF p _ -> True
                    ZeroF -> undefined
                    _ -> undefined

lift : Update b -> Date >=> b
lift fb = Kleisli $ const fb

deserialize : Obligation.Serializable.T t a -> Obligation (ObsArrow a) t a
deserialize = undefined

serialize : Obligation (ObsArrow a) t a -> Obligation.Serializable.T t a
serialize = undefined

template DvP
  with
    bearer: Party
    counterparty: Party

{-
    valueDate : Date
    isin: ISIN
    price: (Decimal, Currency)
    quantity: Decimal
-}
    obligations : Obligations
  where
    -- Note interestingly that `scale` is not distributive when clearing - charges may depend on nominal
    let spot : ISIN -> Date >=> Decimal
        spot isin = Kleisli \t -> do
          (_, Quote{close}) <- fetchByKey (isin, t, executor)
          return $ close
   
        obligations = deserialize this.obligations

        {-obligations : forall f . ISIN -> Date -> Obligation f Date Asset
        obligations isin t =
           give (scalek (     quantity)  (one (Right isin)) : Obligation (->) Date Asset) -- delivery
           `and` scalek (px * quantity)  (one (Left ccy))    -- payment
           where (px, ccy) = price
        -}

        executor = if isBearerExecutor obligations then bearer else counterparty

    signatory bearer, counterparty

    choice
      Election : ContractId DvP with t : Date
      controller executor
        do return undefined

    choice
      Clear : ContractId DvP with t: Date
      controller executor
        do
        let enrich : (Obligation (->) Date Asset) -> (Obligation (->) Date (Update (Charges, Asset)))
            enrich = undefined
              where calcCharges : (Obligation (>=>) Date Asset) -> Date >=> Charges
                    calcCharges = para \case
                        OneF (Right isin) -> do
                          (_, ChargeRule{..}) <- lift $ fetchByKey (isin, executor)
                          return $ fromList [("comm (per $)", commissionPerNominal),
                                             ("comm (per unit)", commissionPerUnit)]

                        ScaleF k (One (Right _isin), _) -> do
                          k' <- k
                          return $ fromList [("comm (per unit)", k')]

                        ScaleF k (One (Left _ccy), _) -> do
                          k' <- k
                          return $ fromList [("comm (per $)", k')]

                        AndF (_, comms1) (_, comms2) -> do
                          comms1' <- comms1
                          comms2' <- comms2
                          return $ merge skip skip (\_ c c' -> Some $ c * c') comms1' comms2'
                                   where skip = const . const $ None

                        _ -> error "Malformed DvP transaction. Should be : And (Scale (One ccy), Scale (One asset))"

            confirm : (Obligation (>=>) t Asset) -> Date >=> SSI
            confirm = cata \case
               OneF (Right isin) -> do
                 (rulesSingletonId, _) <- lift $ fetchByKey @SettlementRule executor
                 lift $ exercise rulesSingletonId $ SettlementInstructions isin
               OneF (Left ccy) -> do
                 (rulesSingletonId, _) <- lift $ fetchByKey @SettlementRule executor
                 lift $ exercise rulesSingletonId $ PaymentInstructions ccy

            settle : SSI -> Charges -> Asset >=> Claim
            settle = undefined
        return undefined


-- Example of how this would be used

createObligations = script do
  buyer <- allocateParty "Buyer"
  seller <- allocateParty "Seller"
  registrar <- allocateParty "Registrar"
  let dividend price ccy date = when (at date) (scalek price (one . Left $ ccy))
      pay qty ccy = give (scalek qty (one . Left $ ccy))
      receive qty sec = scalek qty (one . Right $ sec)
      vod = Security with
              registrar = registrar
              isin = "GB01234567890" 
              countryOfIssue = "GB"
              claims 
                = serialize (
                          dividend 0.65 GBP (date 2020 Dec 1)
                    `and` dividend 0.65 GBP (date 2021 Jan 30)
                )
  submit buyer do 
    createCmd DvP with
      bearer = buyer
      counterparty = seller
      obligations = serialize (pay 10000.0 GBP `and` receive 200.0 vod.isin)
  submit buyer do 
    createCmd DvP with
      bearer = buyer
      counterparty = seller
      obligations 
        = serialize (
                pay 10000.0 GBP 
          `and` when (at $ date 2020 Dec 1) (receive 200.0 vod.isin)
        )
