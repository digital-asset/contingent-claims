{-# LANGUAGE ApplicativeDo #-} --for scripts?
{-# LANGUAGE TypeOperators #-}

module DvPExamples where

import Daml.Script

import Prelude hiding (and, or, time, (.), lookup, foldl, merge)
import Currency
import Obligation
import qualified Obligation.Serializable
import FinancialObligation
import DA.Date (date, Month(..)) --, toDateUTC)
import Category
import DA.Next.Map (Map, MapKey, merge, insert, lookup, fromList)
import DA.Next.Set qualified as Set
import DA.Foldable (foldl)
import Recursion
import Kleisli
import Observation hiding (Asset)
import Observable (PointF)
import Observable qualified as O (pure)
-- import ObservableFunctions

-- Specialized effect-less obligation for DvP
type ISIN = Text
type Asset = Either Currency ISIN
type (>=>) = Kleisli Update
-- type Obligations = Obligation (>=>) Date Asset

-- EXample: Note you have to explicitly specify the type

scalek : forall f t a . (PointF f t Decimal) => Decimal -> Obligation f t a -> Obligation f t a
scalek = scale . O.pure

myZcb : Obligation Observation Date Asset = zcb (date 2020 Dec 1) 100.0 (Left GBP) 

type Charges = Map Text Decimal -- Used to enrich a payment with commission, market charges etc.
data Claim = Claim deriving (Eq, Show)
data SSI = SSI deriving (Eq, Show)

type CountryISO = Text -- Two char code

template Quote
  with
    isin: ISIN
    quoteDate: Date
    close: Decimal
    source: Party
  where
    signatory source
    key (isin, quoteDate, source) : (ISIN, Date, Party)
    maintainer key._3

template Security
  with
    registrar: Party
    -- csd: Party
    isin: ISIN
    countryOfIssue: CountryISO
    -- currency: Currency
    claims: Obligation.Serializable.T
  where
    signatory registrar
    key (isin, registrar) : (ISIN, Party)
    maintainer key._2

template ChargeRule
  with
    operator : Party
    isin: ISIN
    commissionPerNominal: Decimal -- bps
    commissionPerUnit: Decimal
  where
    signatory operator
    key (isin, operator) : (ISIN, Party)
    maintainer key._2

template SettlementRule
  with
    operator: Party
  where
    signatory operator
    key operator: Party
    maintainer key
    controller operator can
      nonconsuming SettlementInstructions : SSI with isin: ISIN
        do
        (_, Security{countryOfIssue}) <- fetchByKey (isin, error "Undefined: fetchByKey maintainer")
        _ <- pure "Do something to derive the SSIs"
        return SSI
      nonconsuming PaymentInstructions : SSI with ccy: Currency
        do
        return $ case ccy of
          USD -> SSI -- fedwire
          GBP -> SSI -- BACS


modify : forall k v . (MapKey k) => (v -> v) -> k -> Map k v -> Map k v
modify f k kvs = foldl (\kvs v -> insert k (f v) kvs) kvs v
                 where v = f <$> lookup k kvs

isBearerExecutor : forall f t a . Obligation f t a -> Bool
isBearerExecutor = cata \case
                    OneF _ -> True
                    GiveF p -> not p
                    ScaleF _ p -> True
                    AndF p _ -> True
                    WhenF p _ -> True
                    ZeroF -> error "Undefined: ZeroF"
                    _ -> error "Undefined: isBearerExecutor"

lift : Update b -> Date >=> b
lift fb = error "Undefined: lift" -- Kleisli $ const fb

deserialize : Party -> Party -> Obligation.Serializable.T -> Obligation Observation Date Asset
deserialize = error "Undefined: deserialize"

serialize : Party -> Party -> Obligation Observation Date Asset -> Update Obligation.Serializable.T
-- seriallze _ _ Zero = pure Obligation.Serializable.Zero_
serialize bearer counterparty (One asset) = do 
  cid <- create $ Obligation.Serializable.One with bearer, counterparty, asset
  return . Obligation.Serializable.One_ $ cid
serialize bearer counterparty (Give obligation) = do
  serialized <- serialize bearer counterparty obligation
  cid <- create $ Obligation.Serializable.Give with bearer, counterparty, obligation = serialized
  return . Obligation.Serializable.Give_ $ cid
serialize bearer counterparty (Scale predicate obligation) = do
  serialized <- serialize bearer counterparty obligation
  unwrappedPredicate <- (predicate.run.runKleisli bearer).run
  cid <- create $ Obligation.Serializable.Scale with bearer, counterparty, predicate = unwrappedPredicate, obligation = serialized
  return $ Obligation.Serializable.Scale_ cid
serialize bearer counterparty (When predicate obligation) = do
  serialized <- serialize bearer counterparty obligation
  unwrappedPredicate <- (predicate.run.runKleisli bearer).run
  cid <- create $ Obligation.Serializable.When with bearer, counterparty, predicate = unwrappedPredicate, obligation = serialized
  return $ Obligation.Serializable.When_ cid
serialize bearer counterparty (And obligation obligation') = do
  serialized <- serialize bearer counterparty obligation
  serialized' <- serialize bearer counterparty obligation'
  cid <- create $ Obligation.Serializable.And with bearer, counterparty, lhs = serialized, rhs = serialized'
  return $ Obligation.Serializable.And_ cid
serialize _ _ Zero = error "Undefined: serialize Zero"
serialize _ _ (Or _ _) = error "Undefined: serialize Or"
serialize _ _ (Cond _ _ _) = error "Undefined: serialize Cond"
serialize _ _ (Anytime _ _) = error "Undefined: serialize Anytime"
serialize _ _ (Until _ _) = error "Undefined: serialize Until"

template DvP
  with
    bearer: Party
    counterparty: Party

{-
    valueDate : Date
    isin: ISIN
    price: (Decimal, Currency)
    quantity: Decimal
-}
    obligations : Obligation.Serializable.T
  where
    -- Note interestingly that `scale` is not distributive when clearing - charges may depend on nominal
    let spot : ISIN -> Date >=> Decimal
        spot isin = Kleisli \t -> do
          (_, Quote{close}) <- fetchByKey (isin, t, executor)
          return $ close
   
        obligations = deserialize bearer counterparty this.obligations

        {-obligations : forall f . ISIN -> Date -> Obligation f Date Asset
        obligations isin t =
           give (scalek (     quantity)  (one (Right isin)) : Obligation (->) Date Asset) -- delivery
           `and` scalek (px * quantity)  (one (Left ccy))    -- payment
           where (px, ccy) = price
        -}

        executor = if isBearerExecutor obligations then bearer else counterparty

    signatory bearer, counterparty

    choice
      Election : ContractId DvP with t : Date
      controller executor
        do return undefined

    choice
      Clear : ContractId DvP with t: Date
      controller executor
        do
        let enrich : (Obligation (->) Date Asset) -> (Obligation (->) Date (Update (Charges, Asset)))
            enrich = undefined
              where calcCharges : (Obligation (>=>) Date Asset) -> Date >=> Charges
                    calcCharges = para \case
                        OneF (Right isin) -> do
                          (_, ChargeRule{..}) <- lift $ fetchByKey (isin, executor)
                          return $ fromList [("comm (per $)", commissionPerNominal),
                                             ("comm (per unit)", commissionPerUnit)]

                        ScaleF k (One (Right _isin), _) -> do
                          k' <- k
                          return $ fromList [("comm (per unit)", k')]

                        ScaleF k (One (Left _ccy), _) -> do
                          k' <- k
                          return $ fromList [("comm (per $)", k')]

                        AndF (_, comms1) (_, comms2) -> do
                          comms1' <- comms1
                          comms2' <- comms2
                          return $ merge skip skip (\_ c c' -> Some $ c * c') comms1' comms2'
                                   where skip = const . const $ None

                        _ -> error "Malformed DvP transaction. Should be : And (Scale (One ccy), Scale (One asset))"

            confirm : (Obligation (>=>) t Asset) -> Date >=> SSI
            confirm = cata \case
               OneF (Right isin) -> do
                 (rulesSingletonId, _) <- lift $ fetchByKey @SettlementRule executor
                 lift $ exercise rulesSingletonId $ SettlementInstructions isin
               OneF (Left ccy) -> do
                 (rulesSingletonId, _) <- lift $ fetchByKey @SettlementRule executor
                 lift $ exercise rulesSingletonId $ PaymentInstructions ccy

            settle : SSI -> Charges -> Asset `Observation` Claim
            settle = undefined
        return undefined

{-
template MasterAgreement
  with
    bearer: Party
    counterparty: Party
  where
    signatory Set.fromList [bearer, counterparty]

    controller bearer can
      Zcb : Obligation.Serializable.T with maturity: Date, nominal: Decimal, ccy: Currency do
        serialize bearer bearer $ zcb maturity nominal (Left ccy)

template FinancialContractProposal
  with
    requestor: Party
    counterparty: Party
    proposal: Obligation.Serializable.T
  where 
    signatory requestor
    observer counterparty
    controller counterparty can
      AcceptFinancialContract : Obligation.Serializable.T do
        deserialize
-}

-- Example of how this would be used
-- Note this can't be written as a script because of the naked 'serialize' call.
createObligations : Scenario () = do
  buyer <- getParty "Buyer"
  seller <- getParty "Seller"
  registrar <- getParty "Registrar"
  let dividend price ccy date = when (at date) (scalek price (one . Left $ ccy))
      pay qty ccy = give (scalek qty (one . Left $ ccy))
      receive qty sec = scalek qty (one . Right $ sec)
  claims <- submit buyer $ serialize buyer buyer (
                          dividend 0.65 GBP (date 2020 Dec 1)
                    `and` dividend 0.65 GBP (date 2021 Jan 30)
                )
  let vod = Security with
              registrar = registrar
              isin = "GB01234567890" 
              countryOfIssue = "GB"
              claims
  dvp <- submit buyer $ serialize buyer buyer (pay 10000.0 GBP `and` receive 200.0 vod.isin)
  submit buyer do 
    create DvP with
      bearer = buyer
      counterparty = buyer
      obligations = dvp
  loan <- submit buyer $ serialize buyer buyer (
                pay 10000.0 GBP 
          `and` when (at $ date 2020 Dec 1) (receive 200.0 vod.isin)
        )
  submit buyer do 
    create DvP with
      bearer = buyer
      counterparty = buyer
      obligations = loan
  return ()
