{-# LANGUAGE ApplicativeDo #-} --for scripts?
{-# LANGUAGE TypeOperators #-}

module DvPExamples where

import Daml.Script

import Prelude hiding (and, or, time, (.), lookup, foldl, merge)
import Currency
import Obligation
import Obligation.Serializable qualified as Serialized
import FinancialObligation
import DA.Date (date, Month(..)) --, toDateUTC)
import Category
import DA.Next.Map (Map, MapKey, merge, insert, lookup, fromList)
import DA.Foldable (foldl)
import Recursion
import Kleisli
import Observation hiding (Asset)
import Observable (PointF)
import Observable qualified as O (pure)
-- import ObservableFunctions

-- Specialized effect-less obligation for DvP
type ISIN = Text
type Asset = Either Currency ISIN
type (>=>) = Kleisli Update
-- type Obligations = Obligation (>=>) Date Asset

-- EXample: Note you have to explicitly specify the type

-- TODO: move out into FinancialContracts or another mobdule
scalek : forall f t a . (PointF f t Decimal) => Decimal -> Obligation f t a -> Obligation f t a
scalek = scale . O.pure

-- myZcb : Obligation Observation Date Asset = zcb (date 2020 Dec 1) 100.0 (Left GBP) 

type Charges = Map Text Decimal -- Used to enrich a payment with commission, market charges etc.
data Claim = Claim deriving (Eq, Show)
data SSI = SSI deriving (Eq, Show)

type CountryISO = Text -- Two char code

template Quote
  with
    isin: ISIN
    quoteDate: Date
    close: Decimal
    source: Party
  where
    signatory source
    key (isin, quoteDate, source) : (ISIN, Date, Party)
    maintainer key._3

template Security
  with
    registrar: Party
    -- csd: Party
    isin: ISIN
    countryOfIssue: CountryISO
    -- currency: Currency
    claims: Serialized.Obligation Date Asset
  where
    signatory registrar
    key (isin, registrar) : (ISIN, Party)
    maintainer key._2

template ChargeRule
  with
    operator : Party
    isin: ISIN
    commissionPerNominal: Decimal -- bps
    commissionPerUnit: Decimal
  where
    signatory operator
    key (isin, operator) : (ISIN, Party)
    maintainer key._2

template SettlementRule
  with
    operator: Party
  where
    signatory operator
    key operator: Party
    maintainer key
    controller operator can
      nonconsuming SettlementInstructions : SSI with isin: ISIN
        do
        (_, Security{countryOfIssue}) <- fetchByKey (isin, error "Undefined: fetchByKey maintainer")
        _ <- pure "Do something to derive the SSIs"
        return SSI
      nonconsuming PaymentInstructions : SSI with ccy: Currency
        do
        return $ case ccy of
          USD -> SSI -- fedwire
          GBP -> SSI -- BACS

isBearerExecutor : forall f t a . Obligation f t a -> Bool
isBearerExecutor = cata \case
                    OneF _ -> True
                    GiveF p -> not p
                    ScaleF _ p -> True
                    AndF p _ -> True
                    WhenF p _ -> True
                    ZeroF -> error "Undefined: ZeroF"
                    _ -> error "Undefined: isBearerExecutor"

lift : Update b -> Date >=> b
lift fb = error "Undefined: lift" -- Kleisli $ const fb

deserialize : Serialized.Obligation t a -> Obligation Observation t a
deserialize = ana \case
  Serialized.Zero -> ZeroF
  Serialized.One a -> OneF a
  Serialized.Give o -> GiveF o
  Serialized.And o o' -> AndF o o'
  Serialized.Or o o' -> OrF o o'
  Serialized.Cond k o o' -> CondF k o o'
  Serialized.Scale k o -> ScaleF k o
  Serialized.When p o -> WhenF p o
  Serialized.Anytime p o -> AnytimeF p o
  Serialized.Until p o -> UntilF p o
  
serialize : Obligation Observation t a -> Serialized.Obligation t a
serialize = ana \case
  Zero -> Serialized.ZeroF
  One a -> Serialized.OneF a
  Give o -> Serialized.GiveF o
  And o o' -> Serialized.AndF o o'
  Or o o' -> Serialized.OrF o o'
  Cond k o o' -> Serialized.CondF k o o'
  Scale k o -> Serialized.ScaleF k o
  When p o -> Serialized.WhenF p o
  Anytime p o -> Serialized.AnytimeF p o
  Until p o -> Serialized.UntilF p o


template DvP
  with
    bearer: Party
    counterparty: Party

    obligations : Serialized.Obligation Date Asset
  where
    let obligations = deserialize this.obligations
        executor = if isBearerExecutor obligations then bearer else counterparty

    signatory bearer, counterparty
{-
    choice
      Election : ContractId DvP with t : Date
      controller executor
        do return undefined

    choice
      Clear : ContractId DvP with t: Date
      controller executor
        do
        let enrich : (Obligation (->) Date Asset) -> (Obligation (->) Date (Update (Charges, Asset)))
            enrich = undefined
              where calcCharges : (Obligation (>=>) Date Asset) -> Date >=> Charges
                    calcCharges = para \case
                        OneF (Right isin) -> do
                          (_, ChargeRule{..}) <- lift $ fetchByKey (isin, executor)
                          return $ fromList [("comm (per $)", commissionPerNominal),
                                             ("comm (per unit)", commissionPerUnit)]

                        ScaleF k (One (Right _isin), _) -> do
                          k' <- k
                          return $ fromList [("comm (per unit)", k')]

                        ScaleF k (One (Left _ccy), _) -> do
                          k' <- k
                          return $ fromList [("comm (per $)", k')]

                        AndF (_, comms1) (_, comms2) -> do
                          comms1' <- comms1
                          comms2' <- comms2
                          return $ merge skip skip (\_ c c' -> Some $ c * c') comms1' comms2'
                                   where skip = const . const $ None

                        _ -> error "Malformed DvP transaction. Should be : And (Scale (One ccy), Scale (One asset))"

            confirm : (Obligation (>=>) t Asset) -> Date >=> SSI
            confirm = cata \case
               OneF (Right isin) -> do
                 (rulesSingletonId, _) <- lift $ fetchByKey @SettlementRule executor
                 lift $ exercise rulesSingletonId $ SettlementInstructions isin
               OneF (Left ccy) -> do
                 (rulesSingletonId, _) <- lift $ fetchByKey @SettlementRule executor
                 lift $ exercise rulesSingletonId $ PaymentInstructions ccy

            settle : SSI -> Charges -> Asset `Observation` Claim
            settle = undefined
        return undefined
-}

createObligations = script do
  buyer <- allocateParty "Buyer"
  seller <- allocateParty "Seller"
  registrar <- allocateParty "Registrar"
  let dividend price ccy date = when (at date) (scalek price (one . Left $ ccy))
      pay qty ccy = give (scalek qty (one . Left $ ccy))
      receive qty sec = scalek qty (one . Right $ sec)
      vod = Security with
              registrar = registrar
              isin = "GB01234567890" 
              countryOfIssue = "GB"
              claims = serialize (
                          dividend 0.65 GBP (date 2020 Dec 1)
                    `and` dividend 0.65 GBP (date 2021 Jan 30)
                )
  submit buyer do 
    createCmd DvP with
      bearer = buyer
      counterparty = buyer
      obligations = serialize (pay 10000.0 GBP `and` receive 200.0 vod.isin)
  submit buyer do 
    createCmd DvP with
      bearer = buyer
      counterparty = buyer
      obligations = serialize (
              pay 10000.0 GBP 
        `and` when (at $ date 2020 Dec 1) (receive 200.0 vod.isin)
        )
  return ()
