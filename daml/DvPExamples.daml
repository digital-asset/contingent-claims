module DvPExamples where

{-# LANGUAGE ApplicativeDo #-} --for scripts?
{-# LANGUAGE TypeOperators #-}

import Prelude hiding (and, or, time, (.), lookup, foldl, merge)
import Obligation
import FinancialObligation
import DA.Date (date, Month(..)) --, toDateUTC)
import Category
import DA.Next.Map (Map, MapKey, merge, insert, lookup, fromList)
import DA.Foldable (foldl)
import Recursion
import Kleisli

-- Specialized effect-less obligation for DvP
type Monad = Action
type (~>) = Kleisli Update
type ISIN = Text
type Asset = Either Currency ISIN
type Obligations = Obligation (~>) Date Asset

-- Asset types
data Currency = GBP | USD deriving  (Eq, Show)

-- EXample: Note you have to explicitly specify the type

myZcb : Obligations  = when (at $ date 2020 Dec 1) (scale (pure 100.0) . one . Left $ GBP)

type Charges = Map Text Decimal -- Used to enrich a payment with commission, market charges etc.
data Claim = Claim deriving (Eq, Show)
data SSI = SSI deriving (Eq, Show)

type CountryISO = Text -- Two char code

template Quote
  with
    isin: ISIN
    quoteDate: Date
    close: Decimal
    source: Party
  where
    signatory source
    key (isin, quoteDate, source) : (ISIN, Date, Party)
    maintainer key._3

template Security
  with
    registrar: Party
    csd: Party
    isin: ISIN
    countryOfIssue: CountryISO
    currency: Currency
  where
    signatory registrar
    key (isin, registrar) : (ISIN, Party)
    maintainer key._2

template ChargeRule
  with
    operator : Party
    isin: ISIN
    commissionPerNominal: Decimal -- bps
    commissionPerUnit: Decimal
  where
    signatory operator
    key (isin, operator) : (ISIN, Party)
    maintainer key._2

template SettlementRule
  with
    operator: Party
  where
    signatory operator
    key operator: Party
    maintainer key
    controller operator can
      nonconsuming SettlementInstructions : SSI with isin: ISIN
        do
        (_, Security{countryOfIssue}) <- fetchByKey (isin, undefined)
        _ <- pure "Do something to derive the SSIs"
        return SSI
      nonconsuming PaymentInstructions : SSI with ccy: Currency
        do
        return $ case ccy of
          USD -> SSI -- fedwire
          GBP -> SSI -- BACS


modify : forall k v . (MapKey k) => (v -> v) -> k -> Map k v -> Map k v
modify f k kvs = foldl (\kvs v -> insert k (f v) kvs) kvs v
                 where v = f <$> lookup k kvs

scalek : forall f t a . (Applicative (f t)) => Decimal -> Obligation f t a -> Obligation f t a
scalek = scale . pure

isBearerExecutor : forall f t a . Obligation f t a -> Bool
isBearerExecutor = cata \case
                    OneF _ -> True
                    GiveF p -> not p
                    ScaleF _ p -> True
                    AndF p _ -> True
                    ZeroF -> undefined
                    _ -> undefined

lift : Update b -> Date ~> b
lift fb = Kleisli $ const fb

template DvP
  with
    bearer: Party
    counterparty: Party
    -- Below this line is state required to re-create the obligation at time t.
    valueDate : Date
    isin: ISIN
    price: (Decimal, Currency)
    quantity: Decimal
    elections: [Bool] -- whether the left branch was taken
    paymentClaims: [Claim] -- claims from external payment system
  where
    -- Note interestingly that `scale` is not distributive when clearing - charges may depend on nominal
    let spot : ISIN -> Date ~> Decimal
        spot isin = Kleisli \t -> do
          (_, Quote{close}) <- fetchByKey (isin, t, executor)
          return $ close

        obligations : forall f . ISIN -> Date -> Obligation f Date Asset
        obligations isin t =
           give (scalek (     quantity)  (one (Right isin)) : Obligation (->) Date Asset) -- delivery
           `and` scalek (px * quantity)  (one (Left ccy))    -- payment
           where (px, ccy) = price

        executor = if isBearerExecutor (obligations isin valueDate) then bearer else counterparty

    signatory bearer, counterparty

    choice
      Election : ContractId DvP with t : Date
      controller executor
        do return undefined

    choice
      Clear : ContractId DvP with t: Date
      controller executor
        do
        let enrich : (Obligation (->) Date Asset) -> (Obligation (->) Date (Update (Charges, Asset)))
            enrich = undefined
              where calcCharges : (Obligation (~>) Date Asset) -> Date ~> Charges
                    calcCharges = para \case
                        OneF (Right isin) -> do
                          (_, ChargeRule{..}) <- lift $ fetchByKey (isin, executor)
                          return $ fromList [("comm (per $)", commissionPerNominal),
                                             ("comm (per unit)", commissionPerUnit)]

                        ScaleF k (One (Right _isin), _) -> do
                          k' <- k
                          return $ fromList [("comm (per unit)", k')]

                        ScaleF k (One (Left _ccy), _) -> do
                          k' <- k
                          return $ fromList [("comm (per $)", k')]

                        AndF (_, comms1) (_, comms2) -> do
                          comms1' <- comms1
                          comms2' <- comms2
                          return $ merge skip skip (\_ c c' -> Some $ c * c') comms1' comms2'
                                   where skip = const . const $ None

                        _ -> error "Malformed DvP transaction. Should be : And (Scale (One ccy), Scale (One asset))"

            confirm : (Obligation (~>) t Asset) -> Date ~> SSI
            confirm = cata \case
               OneF (Right isin) -> do
                 (rulesSingletonId, _) <- lift $ fetchByKey @SettlementRule executor
                 lift $ exercise rulesSingletonId $ SettlementInstructions isin
               OneF (Left ccy) -> do
                 (rulesSingletonId, _) <- lift $ fetchByKey @SettlementRule executor
                 lift $ exercise rulesSingletonId $ PaymentInstructions ccy

            settle : SSI -> Charges -> Asset ~> Claim
            settle = undefined
        return undefined


{-

-- Example of how this would be used

x = script do
  buyer <- allocateParty "Alice"
  seller <- allocateParty "Bob"
  let vod = Security with
              isin = "GB01234567890" 
              claims 
                =     dividend 0.65 GBP (date 2020 Dec 1)
                `and` dividend 0.65 GBP (date 2021 Jan 30)
  submit buyer do 
    createCmd DeliveryVersusPayment with
      bearer = buyer
      counterparty = seller
      obligations = pay 10000.0 GBP `and` receive 200.0 vod
  submit buyer do 
    createCmd DeliveryVersusPayment with
      bearer = buyer
      counterparty = seller
      obligations 
        =     pay 10000.0 GBP 
        `and` when (liftA2 (==) t (pure $ date 2020 Dec 1)) (receive 200.0 vod)
     
-}
