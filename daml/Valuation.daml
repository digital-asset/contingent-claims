daml 1.2
module Valuation where

import Prelude hiding (or,and)
--import DA.Next.Set
import Recursion
import Finance (Currency, Contract)
import qualified Finance

template PricingModels with
    seller: Party
    buyer: Party
  where
    signatory seller, buyer
    controller seller can
      --BlackScholes97: Decimal with r: Decimal, s: Decimal, t: Decimal, contract: Contract
        --do undefined
      AD: Decimal with cid: ContractId Contract, ccy: Currency
       do c <- fetch cid
          let x : Finance.ObsF Decimal (StochasticProcess Decimal)
              x = project $ Finance.konst 1.0
          let p = cata (obligationAlgebra ccy) c.obligations 
          return Finance.undefined

-- | Used to fold the contract into a stochastic process, see ยง4, Figure 4.
obligationAlgebra : Currency -> Finance.ObligationF (StochasticProcess Decimal) -> (StochasticProcess Decimal)
obligationAlgebra _ Finance.ZeroF = Zero
obligationAlgebra term (Finance.OneF base) = Spot base term
obligationAlgebra ccy (Finance.GiveF c) = - c
obligationAlgebra _ (Finance.ScaleF o c) = observableAlgebra (project o) * c

observableAlgebra : Finance.ObsF x (StochasticProcess x) -> (StochasticProcess x)
observableAlgebra (Finance.ConstF x) = Const x

-- | Intermediate representation used for valuation, see ยง4.
data StochasticProcess x = Zero
  | Const x
  | Spot with base: Currency, term: Currency

instance Additive (StochasticProcess Decimal) where
  aunit = Finance.undefined
  (+) = Finance.undefined

instance Multiplicative (StochasticProcess Decimal) where
  munit = Finance.undefined
  (*) = Finance.undefined
         
{-
template PresentValue with
    buyer: Party
    seller: Party
    parameters: Map SecurityId Decimal
    contract: ContractId Contract
  where
    signatory seller
    observer buyer
-}
