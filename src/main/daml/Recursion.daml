module Recursion where

import Category ((>>>),(<<<))
import Arrow ((&&&),(|||))
import Comonad

-- newtype Fix f = Fix { unfix : f (Fix f) }

data Free f a 
  = Pure a
  | Impure (f (Free f a))

data FreeF f a x
  = PureF a
  | ImpureF (f x)
  deriving Functor

instance Functor f => Recursive (Free f a) (FreeF f a) where
  project (Pure a) = PureF a
  project (Impure fx) = ImpureF fx

instance Functor f => Corecursive (Free f a) (FreeF f a) where
  embed _ = undefined

data Cofree f a = Cofree {
  attribute : a,
  unwrap : f (Cofree f a)
} deriving Functor

instance Functor f => Comonad (Cofree f) where
  extract (Cofree a _) = a
  duplicate f = Cofree f $ fmap duplicate f.unwrap

class Functor f => Recursive b f | b -> f b where
  project: b -> f b

  cata : (f a -> a) -> b -> a
  cata f b = (project >>> fmap (cata f) >>> f) b

  para : (f (b, a) -> a) -> b -> a
  para f b = (project >>> fmap (identity &&& para f) >>> f) b

  histo : (f (Cofree f a) -> a) -> b -> a
  histo = gcata seqHisto

  gcata : Comonad w => (forall z . f (w z) -> w (f z)) -> (f (w a) -> a) -> b -> a
  gcata sequence f b = (_gcata sequence f >>> extract >>> f) b

seqHisto : Functor f => f (Cofree f a) -> Cofree f (f a)
seqHisto w = Cofree (fmap extract w) (fmap (seqHisto . unwrap) w)

_gcata 
  : (Recursive b f , Comonad w)
  => (forall z . f (w z) -> w (f z)) 
  -> (f (w a) -> a) 
  -> b 
  -> w (f (w a))
_gcata sequence f b = (project >>> fmap (_gcata sequence f >>> fmap f >>> duplicate) >>> sequence) b

class Functor f => Corecursive b f | f -> b where
  embed: f b -> b

  ana : (a -> f a) -> a -> b
  ana f b = (embed <<< fmap (ana f) <<< f) b

  apo : (a -> f (Either b a)) -> a -> b
  apo f b = (embed <<< fmap (identity ||| apo f) <<< f) b

  futu : (a -> f (Free f a)) -> a -> b
  futu = undefined

  gana : Monad m => (forall z . m (f z) -> f (m z)) -> (a -> f (m a)) -> a -> b
  gana cosequence f a = (_gana cosequence f <<< pure <<< f) a

_gana 
  : (Corecursive b f, Monad m)
  => (forall z . m (f z) -> f (m z))
  -> (a -> f (m a))
  -> m (f (m a))
  -> b
_gana cosequence f b = (embed <<< fmap (_gana cosequence f <<< fmap f <<< join) <<< cosequence) b
  

-- Standard Base Functors

data ListF a x = Nil | Cons with value: a, pattern: x deriving Functor

instance Recursive [a] (ListF a) where
  project [] = Nil
  project (a :: as) = Cons a as

instance Corecursive [a] (ListF a) where
  embed Nil = []
  embed (Cons a as) = a :: as

oursum = cata \case
           Nil -> 0
           Cons x acc -> acc + x

s = oursum [1..20]
