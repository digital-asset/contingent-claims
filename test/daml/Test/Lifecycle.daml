--
-- Copyright (c) 2021, Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0
--

-- TODO: this should all be moved into the "Contingent claims" library. There is nothing specific to the marketplace here.
{-# LANGUAGE ApplicativeDo #-}
{-# LANGUAGE UndecidableInstances #-} --needed to derive cofree Show,Eq

module Test.Lifecycle where

import ContingentClaims.Claim hiding (C, F)
import ContingentClaims.Observable qualified as O
import ContingentClaims.Observation (Observation)
import ContingentClaims.Observation qualified as O
import ContingentClaims.Lifecycle qualified as Lifecycle
import ContingentClaims.Util
import ContingentClaims.FinancialClaim (at)
import DA.Assert ((===))
import Daml.Control.Arrow (runKleisli)
import DA.Date (date, Month(..), addDays)
import Daml.Control.Recursion
import Daml.Script
import Prelude hiding (enumerate, length, or, and)
import DA.Action ((>=>))

type C = Claim Observation Date Text
type F = ClaimF Observation Date Text

deriving instance Show C
deriving instance (Show a, Show (f (Cofree f a))) => Show (Cofree f a)
deriving instance (Eq a, Eq (f (Cofree f a))) => Eq (Cofree f a)
deriving instance Show (F (Cofree F Int))
deriving instance Eq (F (Cofree F Int))

[a,b,c] = ["a","b","c"]

-- This test replaces leaves (i.e. One/Zero) with `One "processed"` if they were reached
testLazy = script do
  let today = date 1970 Jan 1
      tomorrow = today `addDays` 1
      two : O.Observation Date Decimal = O.pure 2.0
  
  let processedNodeF = OneF "processed"
      processedNode : C = embed processedNodeF
      doObserve: Text -> Date -> Script Decimal = const . const . pure $ 0.0
      f = runKleisli . apoM (Lifecycle.lazily' doObserve >=> process)
          where process (OneF _) = pure $ pure <$> processedNodeF
                process ZeroF = pure $ pure <$> processedNodeF
                process otherF = pure otherF


  res <- f (One a) today
  res === processedNode

  res <- f Zero tomorrow
  res === processedNode

  res <- f (When (at tomorrow) $ Scale two (One a)) today
  res === When (at tomorrow) (Scale two (One a))

  res <- f (When (at tomorrow) $ Scale two (One a)) tomorrow
  res === When (at tomorrow) (Scale two processedNode)

  res <- f (Cond (at tomorrow) (One a) (One b)) today
  res === Cond (at tomorrow) (One a) processedNode

  res <- f (Cond (at tomorrow) (One a) (One b)) tomorrow
  res === Cond (at tomorrow) processedNode (One b)

  res <- f (When (O.time O.== O.pure today) (When (O.time O.== O.pure tomorrow) (One a)) ) tomorrow
  res === (When (O.time O.== O.pure today) (When (O.time O.== O.pure tomorrow) (One a)) )

  res <- f (When (O.pure today O.<= O.time) (When (O.time O.== O.pure tomorrow) (One a)) ) tomorrow
  res === (When (O.pure today O.<= O.time) (When (O.time O.== O.pure tomorrow) processedNode) )
