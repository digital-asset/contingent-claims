--
-- Copyright (c) 2021, Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0
--

-- TODO: this should all be moved into the "Contingent claims" library. There is nothing specific to the marketplace here.
{-# LANGUAGE ApplicativeDo #-}
{-# LANGUAGE UndecidableInstances #-} --needed to derive cofree Show,Eq

module Test.Lifecycle where

import ContingentClaims.Claim hiding (C, F)
import ContingentClaims.FinancialClaim (at, fixed, european)
import ContingentClaims.Lifecycle qualified as Lifecycle
import ContingentClaims.Observable qualified as O
import ContingentClaims.Observation (Observation())
import ContingentClaims.Observation qualified as O
import ContingentClaims.Util
import DA.Action ((>=>))
import DA.Assert ((===))
import DA.Date (date, Month(..), addDays, toDateUTC)
import DA.Time (time)
import Daml.Control.Arrow (runKleisli)
import Daml.Control.Monad.Writer (runWriterT)
import Daml.Control.Recursion
import Daml.Script
import Prelude hiding (enumerate, length, or, and)

type C = Claim Observation Date Text
type F = ClaimF Observation Date Text

deriving instance Show C
deriving instance Show a => Show (F a)
deriving instance Eq a => Eq (F a)

[a,b,c] = ["a","b","c"]
today = date 1970 Jan 1
tomorrow = today `addDays` 1
afterTomorrow = tomorrow `addDays` 1
two : O.Observation Date Decimal = O.pure 2.0
observe25: Text -> Date -> Script Decimal = const . const . pure $ 25.0
(false, true) = (O.BoolConst False, O.BoolConst True)
getDate = toDateUTC <$> getTime
setDate = setTime . noon where noon d = time d 12 0 0

-- | This test marks leaves (i.e. `One`/`Zero`) with `acquired` if they were reached.
-- It also removes intermediate `When`/`Cond` so they are not processed twice, accidentaly.
testAcquire = script do
  let acquiredF asset = OneF $ "acquired " <> asset
      acquired asset : C = embed $ acquiredF asset
      f = runKleisli . apoM (Lifecycle.acquire' observe25 >=> process)
          where process (OneF asset) = pure $ pure <$> acquiredF asset
                process ZeroF = pure $ pure <$> acquiredF "0"
                process otherF = pure otherF


  res <- f (One a) today
  res === acquired a

  res <- f Zero tomorrow
  res === acquired "0"

  res <- f (When (at tomorrow) $ Scale two (One a)) today
  res === When (at tomorrow) (Scale two (One a))

  res <- f (When (at tomorrow) $ Scale two (One a)) tomorrow
  res === Scale two (acquired a)

  res <- f (Cond (at tomorrow) (One a) (One b)) today
  res === acquired b

  res <- f (Cond (at tomorrow) (One a) (One b)) tomorrow
  res === acquired a

  res <- f (When (O.time O.== O.pure today) (When (O.time O.== O.pure tomorrow) (One a)) ) tomorrow
  res === (When (O.time O.== O.pure today) (When (O.time O.== O.pure tomorrow) (One a)) )

  res <- f (When (O.pure today O.<= O.time) (When (O.time O.== O.pure tomorrow) (One a)) ) tomorrow
  res === acquired a

  res <- f (One a `Or` One b) today
  res === (acquired a `Or` acquired b)

  res <- f (Anytime true (One a)) today
  res === Anytime true (acquired a)

  res <- f (Anytime false (One a)) today
  res === Anytime false (One a)

  res <- f (Until false (One a)) today
  res === Until false (acquired a)

  res <- f (Until true (One a)) today
  res === Until true (One a)

-- | This test replaces all leaves with Zeros, logging their qty/asset pair into a `Writer`.
-- It ignores `When/Cond` nodes altogether.
testSettle = script do
  let f = runKleisli
          . fmap (uncurry Lifecycle.Result)
          . runWriterT
          . apoM (Lifecycle.settle' observe25)
          . (1.0, )

  Lifecycle.Result{remaining, pending} <- f (Scale two Zero : C) today
  remaining === Scale two Zero
  pending === []

  Lifecycle.Result{remaining, pending} <- f (Scale two (One a)) today
  remaining === Scale two Zero
  pending === [(2.0, a)]

  Lifecycle.Result{remaining, pending} <- f (Give (One a)) today
  remaining === Give Zero
  pending === [(-1.0 , a)]

  Lifecycle.Result{remaining, pending} <- f (Scale two (One a `And` One b)) today
  remaining === Scale two (Zero `And` Zero)
  pending === [(2.0, a), (2.0, b)]

  Lifecycle.Result{remaining, pending} <- f (Scale two (One a) `And` Scale two (One b)) today
  remaining === (Scale two Zero `And` Scale two Zero)
  pending === [(2.0, a), (2.0, b)]

  Lifecycle.Result{remaining, pending} <- f (When false (One a)) today
  remaining === When false Zero
  pending === pure (1.0, a)

  Lifecycle.Result{remaining, pending} <- f (Anytime false (One a)) today
  remaining === Anytime false (One a)
  pending === []

-- | Replace any `Or/Anytime` nodes with the elections that have been made.
testExercise = script do
  let f election = ana (Lifecycle.exercise' election)
  
  let rem = f (One a) (One a `Or` One b)
  rem === One a

  let rem = f (One b) (One a `Or` One b)
  rem === One b

  let rem = f (One c) (One a `Or` One b)
  rem === One a `Or` One b

  let rem = f (One a) (Anytime true (One a))
  rem === One a

  let rem = f (One a) (Anytime false (One a))
  rem === One a

  let rem = f (One c) (Anytime true (One a))
  rem === Anytime true (One a)

-- | Lifecycle a bond with three fixing dates. Uses ledger time effects.
testBond = script do
  let principal = 1_000.0
      coupon = principal * 0.015
      bond = fixed principal coupon a

  setDate today
  t <- getDate

  Lifecycle.Result{remaining, pending} <- Lifecycle.settle observe25 (bond [today, tomorrow, afterTomorrow]) t
  remaining === bond [tomorrow, afterTomorrow]
  pending === [(15.0, a)]

  setDate tomorrow
  t <- getDate

  Lifecycle.Result{remaining, pending} <- Lifecycle.settle observe25 remaining t
  remaining === bond [afterTomorrow]
  pending === [(15.0, a)]

  -- Check bond coupon doesn't get processed twice
  Lifecycle.Result{remaining, pending} <- Lifecycle.settle observe25 remaining t
  remaining === bond [afterTomorrow]
  pending === []

  setDate afterTomorrow
  t <- getDate

  Lifecycle.Result{remaining, pending} <- Lifecycle.settle observe25 remaining t
  remaining === Zero
  pending === [(15.0, a), (1_000.0, a)]

testEuropeanCall = script do
  let strike = 23.0
      payoff = Scale (O.observe "spot" O.- O.pure strike) (One a)
      option = european tomorrow payoff

  setDate today
  t <- getDate

  remaining <- Lifecycle.exercise observe25 Zero option t
  remaining === option

  Lifecycle.Result{remaining, pending} <- Lifecycle.settle observe25 option t
  remaining === option
  pending === []

  setDate tomorrow
  t <- getDate

  remaining <- Lifecycle.exercise observe25 payoff option t
  remaining === payoff

  Lifecycle.Result{remaining, pending} <- Lifecycle.settle observe25 remaining t
  remaining === Zero
  pending === pure (2.0, a)
