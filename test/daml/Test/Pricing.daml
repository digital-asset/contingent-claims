module Test.Pricing where

import ContingentClaims.Claim
import ContingentClaims.FinancialClaim (european, american)
import ContingentClaims.Observable qualified as O
import ContingentClaims.Observation (Observation)
import ContingentClaims.MathML qualified as MathML
import ContingentClaims.Math.Stochastic (fapf, simplify, riskless, gbm, Expr(..))

import Daml.Script
import DA.Assert
data Instrument = USD | EUR | AMZN | APPL deriving (Show, Eq)

call : Instrument -> Decimal -> Instrument -> Claim Observation t Decimal Instrument
call s k a = Scale (O.observe s - O.pure k) $ One a

margrabe s1 s2 a = Scale (O.observe s1 - O.observe s2) $ One a

disc USD = riskless "r_USD"
disc EUR = riskless "r_EUR"
disc other = error $ "disc: " <> show other

exch AMZN _ = gbm "μ_AMZN" "σ_AMZN"
exch APPL _ = gbm "μ_APPL" "σ_APPL"
exch a a' = error $ "exch: " <> show a <> "/" <> show a'

today = "t"
maturity = "T"

-- This is needed because of the way we define `american`
instance Enum Text where
  toEnum 1 = "t"
  toEnum 2 = "T"
  toEnum 3 = "T+1"
  toEnum x = error $ "toEnum not handled " <> show x
  fromEnum "t" = 1
  fromEnum "T" = 2
  fromEnum "T+1" = 3
  fromEnum x = error $ "fromEnum not handled " <> x

valueCall = script do
  let formula = fapf USD disc exch today $ european maturity (call AMZN 3300.0 USD)
      s = simplify formula
  debug . show . MathML.presentation $ s
  s === Const 0.0

valueMargrabe = script do
  let formula = fapf USD disc exch today $ european maturity (margrabe AMZN APPL USD)
      s = simplify formula
  debug . show . MathML.presentation $ s
  s === Const 0.0

valueAmerican = script do
  let formula = fapf USD disc exch today $ american today maturity (call AMZN 3300.0 USD)
      s = simplify formula
  debug . show . MathML.presentation $ s
  s === Const 0.0
