module Test.Pricing where

import ContingentClaims.Claim
import ContingentClaims.FinancialClaim (european, american)
import ContingentClaims.Observable qualified as O
import ContingentClaims.Observation (Observation)
import ContingentClaims.MathML qualified as MathML
import ContingentClaims.Math.Stochastic (fapf, {- simplify, -} riskless, gbm, Expr(..), unitIdentity, IsIdentifier(..))
import Daml.Control.Recursion (cata)

import Daml.Script
import DA.Assert
import Prelude hiding (max)

data Instrument = USD | EUR | AMZN | APPL deriving (Show, Eq)

call : Instrument -> Decimal -> Instrument -> Claim Observation t Decimal Instrument
call s k a = Scale (O.observe s - O.pure k) $ One a

margrabe s1 s2 a = Scale (O.observe s1 - O.observe s2) $ One a

-- | subscript
sub x s = MathML.mi x `MathML.msub` MathML.mi s

disc USD = riskless $ "r" `sub` show USD
disc EUR = riskless $ "r" `sub` show EUR
disc other = error $ "disc: " <> show other

exch AMZN _ = gbm ("μ" `sub` show AMZN) ("σ" `sub` show AMZN)
exch APPL _ = gbm ("μ" `sub` show APPL) ("σ" `sub` show APPL)
exch a a' = error $ "exch: " <> show a <> "/" <> show a'

t = MathML.mi "t"  -- today
t' = MathML.mi "T" -- maturity

instance IsIdentifier MathML.Xml where
  localVar i = "τ" `sub` show i

instance Additive (Expr t) where
  (+) = curry Add
  negate = Neg
  aunit = Const 0.0

instance Multiplicative (Expr t) where
  (*) = curry Mul
  x ^ y = curry Pow x $ Const (intToDecimal y)
  munit = Const 1.0

instance Divisible (Expr t) where
  x / y = curry Mul x . curry Pow y . Neg . Const $ 1.0

instance Number (Expr t) where

max x y = I (x, y) * x + I (y, x) * y

-- This is needed because Scale x (One USD) = x * 1.0. It would make writing
-- the expressions by hand tedious
multIdentity = cata unitIdentity

-- Helper to compare the output in XML format (paste this into a browser)
print f e = do debug $ "Formula:" <> prnt f 
               debug $ "Expected:" <> prnt e
  where prnt = show . MathML.presentation {- . simplify -} 

valueCall = script do
  let formula = fapf USD disc exch t $ european t' (call AMZN 3300.0 USD)
      s = Proc "AMZN" (exch AMZN USD)
      k = Const 3300.0
      usd = Proc "USD" (disc USD)
      expect = usd t * E (max (s t' - k) aunit / usd t') t
  print formula expect
  multIdentity formula === expect

valueMargrabe = script do
  let formula = fapf USD disc exch t $ european t' (margrabe AMZN APPL USD)
      s = Proc "AMZN" (exch AMZN USD)
      s' = Proc "APPL" (exch APPL USD)
      usd = Proc "USD" (disc USD)
      expect = usd t * E (max (s t' - s' t') aunit / usd t') t
  print formula expect
  multIdentity formula === expect

valueAmerican = script do
  let formula = fapf USD disc exch t $ american t t' (call APPL 142.50 USD)
      s = Proc "APPL" (exch APPL USD)
      k = Const 142.50
      usd = Proc "USD" (disc USD)
      τ = "τ" `sub` show 0
      expect = Sup t τ (usd t * E (max (s τ - k) aunit * I (Ident τ, Ident t') / usd τ ) t)
  print formula expect
  multIdentity formula === expect
    

-- Check to see that the subscript numbering works
testMonadicBind = script do
  let τ₀ = "τ" `sub` show 0
      τ₁ = "τ" `sub` show 1
      t₀ = "t" `sub` show 0
      t₁ = "t" `sub` show 1
      usd = Proc "USD" (disc USD)
      formula = fapf USD disc exch t $ Anytime (O.TimeGte t₀) (Anytime (O.TimeGte t₁) (One USD))
      expect = Sup t₀ τ₀ (usd t * E (Sup t₁ τ₁ (usd τ₀ * E (munit / usd τ₁) τ₀) / usd τ₀) t) -- note the innermost 1/USD_τ₁ is mult identity
  print formula expect
  multIdentity formula === multIdentity expect
