-- Copyright (c) 2022 Digital Asset (Switzerland) GmbH and/or its affiliates. All rights reserved.
-- SPDX-License-Identifier: Apache-2.0

module Test.Pricing2 where

import ContingentClaims.Claim
import ContingentClaims.Observation qualified as O
import ContingentClaims.Math.AcquisitionTime
import ContingentClaims.Math.Expression
import ContingentClaims.Math.Stochastic2

import Daml.Script
import DA.Assert
import DA.Date
import DA.Tuple (thd3)
import Prelude hiding (max, (<=))

type C = Claim Date Decimal Text Text

-- | Assets
[a,b,c] = ["a","b","c"]
ccy = "USD"

-- | Dates
t0 = date 1970 Jan 1
t1 = succ t0
t2 = succ t1

-- | Observations
two : O.Observation Date Decimal Text = O.pure 2.0

-- | Functions performing observations
observe25: Text -> Date -> Script Decimal = const . const . pure $ 25.0
observeDayOfMonth _ d = pure . intToDecimal . thd3 . toGregorian $ d

-- | Inequalities
false = TimeGte $ date 3000 Jan 1
true = TimeGte $ date 1970 Jan 1
atT1 = TimeGte t1

-- Helper expressions
disc = Proc $ Disc ccy
exch = Proc $ Exch a ccy

-- max x y = I (x, y) * x + I (y, x) * y

-- This is needed because scale x (one USD) = x * 1.0. It would make writing
-- the expressions by hand tedious
-- multIdentity = cata unitIdentity

-- | Valuation of `One` and `Zero` nodes.
testValuationBasic : Script()
testValuationBasic = do

  value <- fapf observe25 ccy t0 t0 (one a)
  value === Proc (Exch a ccy)

  value <- fapf observe25 ccy t0 t0 (one ccy)
  value === Const 1.0

  value <- fapf observe25 ccy t0 t0 zero
  value === Const 0.0

  pure ()

-- | Valuation of `When` nodes.
testValuationWhen : Script()
testValuationWhen = do
  -- 1. When (TimeGte t) ...
  let
    c1 = when atT1 $ one a
    expect = E (disc * exch) τ f / disc
        where
          f = Time t0 -- filtration (i.e. available information)
          τ = Time t1 -- stopping time defined by the `When` node

  -- At `t0` the stopping rule defined by `When` is not verified, so we take expectation of discounted payoff
  value <- fapf observe25 ccy t0 t0 c1
  value === expect

  -- At `t1` the stopping rule is verified, so we get rid of the `When` node
  value <- fapf observe25 ccy t1 t0 c1
  value === exch

  -- 1. When (TimeLte t) ...

  -- 3. When (o1 <= o2) ...
  let
    pred = Lte (O.Const 100.0, O.observe "spot") -- spot greater or equal than 100.0
    c2 = when pred $ one a

    f = Time t0 -- filtration
    τ = AtInequality [TimeGte t0, pred] -- stopping rule

  value <- fapf observe25 ccy t0 t0 c2
  value === E (disc * exch) τ f / disc

  -- We do not consider the case when the stopping rule is verified before or at t,
  -- given that the valuation focuses on claims that are "up-to-date" with respect to lifecycle events
  -- and the lifecycle function replaces verified stochastic stopping rule with deterministic ones

testValuationScale : Script()
testValuationScale = do
  let
    observable  = O.Const 5.0 + O.observe "spot"
    claim : C = when atT1 $ scale observable $ one a

    f = Time t0 -- filtration
    τ = Time t1 -- stopping rule
    obsProcess = Const 5.0 + Proc (Observable "spot")
    expect = E (disc * (obsProcess * exch) ) τ f / disc

  -- At `t0` the stopping rule is not verified
  value <- fapf observe25 ccy t0 t0 claim
  value === expect

  -- At `t1` the stopping rule is verified
  value <- fapf observe25 ccy t1 t0 claim
  value === (Const 5.0 + Const 25.0) * exch

  pure ()

testValuationCond : Script()
testValuationCond = do
  let
    p1 = O.Const 5.0 <= O.observe "spot"
    c1 : C = when atT1 $ cond p1 (one a) zero
    p2 = O.observe "spot" <= O.Const 5.0
    c2 : C = when atT1 $ cond p2 (one a) zero

    f = Time t0 -- filtration
    τ = Time t1 -- stopping rule
    expect = E (disc * (I p1 * exch + (Const 1.0 - I p1) * aunit) ) τ f / disc

  -- At `t0` the stopping rule is not verified
  value <- fapf observe25 ccy t0 t0 c1
  value === expect

  -- At `t1` the stopping rule is verified
  value <- fapf observe25 ccy t1 t0 c1
  value === exch

  value <- fapf observe25 ccy t1 t0 c2
  value === aunit

  pure ()

  -- TODO : write helper function to collect observables (catamorphism)

  -- TODO : write helper function to collect relevant fixing dates (for the purpose of MC simulation)